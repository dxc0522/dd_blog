{"meta":{"title":"梦回年少","subtitle":"愿你久经沧桑，归来仍是少年","description":"当你出生哭着来到人世时，你周围的人都在笑着迎接你的到来，所以你在生命历程中不要辜负你身边的人，应该善待他人，尽一切努力，走好人生的每一步。","author":"DouDou","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2021-05-19T11:18:03.694Z","updated":"2021-05-19T11:18:03.694Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-05-19T11:18:03.702Z","updated":"2021-05-19T11:18:03.702Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":".pop-container { padding: 2px 6px 6px; background: linear-gradient(to right,#a1c4fd,#c2e9fb)!important; border-radius: 10px; } .botui-container { border-radius: 10px; } [さくら荘のcungudafa] 与 cungudafa （ 真（ま）白（しろ） ） 对话中..."},{"title":"所有分类","date":"2021-05-19T11:18:04.070Z","updated":"2021-05-19T11:18:04.070Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-05-19T11:18:04.071Z","updated":"2021-05-19T11:18:04.071Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"留君言","date":"2021-05-19T11:18:04.071Z","updated":"2021-05-19T11:18:04.071Z","comments":true,"path":"message/index.html","permalink":"http://yoursite.com/message/index.html","excerpt":"","text":"轻言两句 人生如梦，一樽还酹江月。 【宋代】苏轼《念奴娇·赤壁怀古》 有什么想说的，有什么想问，就在下方留言吧，收到我会第一时间回复！请尽情灌水吧！😉 .poem-wrap { position: relative; width: 730px; max-width: 80%; border: 2px solid #797979; border-top: 0; text-align: center; margin: 80px auto; } .poem-wrap h1 { position: relative; margin-top: -20px; display: inline-block; letter-spacing: 4px; color: #797979; border-bottom: none; font-weight:bold; } .poem-wrap h1:before{ height:0; } .poem-wrap p { width: 70%; margin: auto; line-height: 30px; color: #797979; } .poem-wrap p#poem { text-align: center; font-size: 25px; } .poem-wrap p#info { text-align: center; font-size: 15px; margin: 15px auto; } .poem-border { position: absolute; height: 2px; width: 27%; background-color: #797979; } .poem-right { right: 0; } .poem-left { left: 0; } @media (max-width: 685px) { .poem-border { width: 18%; } } @media (max-width: 500px) { .poem-wrap { margin-top: 60px; margin-bottom: 20px; border-top: 2px solid #797979; } .poem-wrap h1 { margin: 20px 6px; } .poem-border { display: none; } }"},{"title":"","date":"2021-05-19T11:18:04.071Z","updated":"2021-05-19T11:18:04.071Z","comments":true,"path":"mylist/index.html","permalink":"http://yoursite.com/mylist/index.html","excerpt":"","text":""},{"title":"Page","date":"2013-12-26T14:52:56.000Z","updated":"2021-05-19T11:18:04.072Z","comments":true,"path":"page/index.html","permalink":"http://yoursite.com/page/index.html","excerpt":"","text":"This is a page test."},{"title":"所有标签","date":"2021-05-19T11:18:04.072Z","updated":"2021-05-19T11:18:04.072Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-05-19T11:18:03.702Z","updated":"2021-05-19T11:18:03.702Z","comments":true,"path":"assets/css/base.css","permalink":"http://yoursite.com/assets/css/base.css","excerpt":"","text":"#veditor { background: url(https://cdn.jsdelivr.net/gh/XuxuGood/cdn@master/blogImages/valine/comment.webp) 100% 100% no-repeat; } #veditor:focus { background-position-y: 400px; transition: all 0.2s ease-in-out 0s; }"},{"title":"","date":"2021-05-19T11:18:03.702Z","updated":"2021-05-19T11:18:03.702Z","comments":true,"path":"assets/css/botui-theme-default.css","permalink":"http://yoursite.com/assets/css/botui-theme-default.css","excerpt":"","text":"@import url(https://fonts.googleapis.com/css?family=Open+Sans);.botui-container{font-size:14px;background-color:#fff;font-family:\"Open Sans\",sans-serif}.botui-messages-container{padding:10px 20px}.botui-actions-container{padding:10px 20px}.botui-message{min-height:30px}.botui-message-content{padding:7px 13px;border-radius:15px;color:#595a5a;background-color:#ebebeb}.botui-message-content.human{color:#f7f8f8;background-color:#919292}.botui-message-content.text{line-height:1.3}.botui-message-content.loading{background-color:rgba(206,206,206,.5);line-height:1.3;text-align:center}.botui-message-content.embed{padding:5px;border-radius:5px}.botui-message-content-link{color:#919292}.botui-actions-text-input{border:0;outline:0;border-radius:0;padding:5px 7px;font-family:\"Open Sans\",sans-serif;background-color:transparent;color:#595a5a;border-bottom:1px solid #919292}.botui-actions-text-submit{color:#fff;width:30px;padding:5px;height:30px;line-height:1;border-radius:50%;border:1px solid #919292;background:#777979}.botui-actions-buttons-button{border:0;color:#fff;line-height:1;cursor:pointer;font-size:14px;font-weight:500;padding:7px 15px;border-radius:4px;font-family:\"Open Sans\",sans-serif;background:#777979;box-shadow:2px 3px 4px 0 rgba(0,0,0,.25)}.botui-actions-text-select{border:0;outline:0;border-radius:0;padding:5px 7px;font-family:\"Open Sans\",sans-serif;background-color:transparent;color:#595a5a;border-bottom:1px solid #919292}.botui-actions-text-searchselect{border:0;outline:0;border-radius:0;padding:5px 7px;font-family:\"Open Sans\",sans-serif;background-color:transparent;color:#595a5a;border-bottom:1px solid #919292}.botui-actions-text-searchselect .dropdown-toggle{border:none!important}.botui-actions-text-searchselect .selected-tag{background-color:transparent!important;border:0!important}.slide-fade-enter-active{transition:all .3s ease}.slide-fade-enter,.slide-fade-leave-to{opacity:0;transform:translateX(-10px)}.dot{width:.5rem;height:.5rem;border-radius:.5rem;display:inline-block;background-color:#919292}.dot:nth-last-child(1){margin-left:.3rem;animation:loading .6s .3s linear infinite}.dot:nth-last-child(2){margin-left:.3rem;animation:loading .6s .2s linear infinite}.dot:nth-last-child(3){animation:loading .6s .1s linear infinite}@keyframes loading{0%{transform:translate(0,0);background-color:#ababab}25%{transform:translate(0,-3px)}50%{transform:translate(0,0);background-color:#ababab}75%{transform:translate(0,3px)}100%{transform:translate(0,0)}}"},{"title":"","date":"2021-05-19T11:18:03.703Z","updated":"2021-05-19T11:18:03.703Z","comments":true,"path":"assets/css/botui.min.css","permalink":"http://yoursite.com/assets/css/botui.min.css","excerpt":"","text":"/* * botui 0.3.9 * A JS library to build the UI for your bot * https://botui.org * * Copyright 2019, Moin Uddin * Released under the MIT license. */ a.botui-message-content-link:focus{outline:thin dotted}a.botui-message-content-link:focus:active,a.botui-message-content-link:focus:hover{outline:0}form.botui-actions-text{margin:0}button.botui-actions-buttons-button,input.botui-actions-text-input{margin:0;font-size:100%;line-height:normal;vertical-align:baseline}button.botui-actions-buttons-button::-moz-focus-inner,input.botui-actions-text-input::-moz-focus-inner{border:0;padding:0}button.botui-actions-buttons-button{cursor:pointer;-webkit-appearance:button} .botui-app-container{width:100%;height:100%;line-height:1}@media (min-width:400px){.botui-app-container{width:400px;height:500px;margin:0 auto}}.botui-container{width:100%;height:100%;overflow-y:auto;overflow-x:hidden}.botui-message{margin:10px 0;min-height:20px}.botui-message:after{display:block;content:\"\";clear:both}.botui-message-content{width:auto;max-width:75%;display:inline-block}.botui-message-content.human{float:right}.botui-message-content iframe{width:100%}.botui-message-content-image{margin:5px 0;display:block;max-width:200px;max-height:200px}.botui-message-content-link{text-decoration:underline}.profil{position:relative;border-radius:50%}.profil.human{float:right;margin-left:5px}.profil.agent{float:left;margin-right:5px}.profil>img{width:26px;height:26px;border:2px solid #e8e8e8}.profil>img.agent{content:url(http://decodemoji.com/img/logos/blue_moji_hat.svg);border-radius:50%}button.botui-actions-buttons-button{margin-top:10px;margin-bottom:10px}button.botui-actions-buttons-button:not(:last-child){margin-right:10px}@media (min-width:400px){.botui-actions-text-submit{display:none}}"},{"title":"","date":"2021-05-19T11:18:03.768Z","updated":"2021-05-19T11:18:03.768Z","comments":true,"path":"assets/js/diy_style.js","permalink":"http://yoursite.com/assets/js/diy_style.js","excerpt":"","text":"function loadingPage() { $(function () { var a_idx = 0; // 鼠标点击出现文字 $(\"body\").click(function (e) { var a = new Array (\"富强\", \"民主\", \"文明\", \"和谐\", \"自由\", \"平等\", \"公正\", \"法治\", \"爱国\", \"敬业\", \"诚信\", \"友善\"); var $i = $(\"\").text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css({ \"z-index\": 5, \"top\": y - 20, \"left\": x, \"position\": \"absolute\", \"font-weight\": \"bold\", \"color\": \"rgb(\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \",\" + ~~(255 * Math.random()) + \")\" }); $(\"body\").append($i); $i.animate({ \"top\": y - 180, \"opacity\": 0 }, 3000, function () { $i.remove(); }); }); setTimeout(function () { $(\".buryit\").removeAttr(\"onclick\"); }, 2000); var binft = function (r) { function t() { return b[Math.floor(Math.random() * b.length)] } function e() { return String.fromCharCode(94 * Math.random() + 33) } function n(r) { for (var n = document.createDocumentFragment(), i = 0; r > i; i++) { var l = document.createElement(\"span\"); l.textContent = e(), l.style.color = t(), n.appendChild(l) } return n } function i() { var t = o[c.skillI]; c.step ? c.step-- : (c.step = g, c.prefixP < l.length ? (c.prefixP >= 0 && (c.text += l[c.prefixP]), c.prefixP++) : \"forward\" === c.direction ? c.skillP < t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = \"backward\", c.delay = a) : c.skillP > 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = \"forward\")), r.textContent = c.text, r.appendChild(n(c.prefixP < l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d) } var l = \"\", o = [\"青青陵上柏，磊磊涧中石。\", \"人生天地间，忽如远行客。\", \"斗酒相娱乐，聊厚不为薄。\", \"驱车策驽马，游戏宛与洛。\", \"洛中何郁郁，冠带自相索。\", \"长衢罗夹巷，王侯多第宅。\", \"两宫遥相望，双阙百余尺。\", \"极宴娱心意，戚戚何所迫？\", \"相逢意气为君饮，系马高楼垂柳边。\"].map(function (r) { return r + \"\" }), a = 2, g = 1, s = 5, d = 75, b = [\"rgb(110,64,170)\", \"rgb(150,61,179)\", \"rgb(191,60,175)\", \"rgb(228,65,157)\", \"rgb(254,75,131)\", \"rgb(255,94,99)\", \"rgb(255,120,71)\", \"rgb(251,150,51)\", \"rgb(226,183,47)\", \"rgb(198,214,60)\", \"rgb(175,240,91)\", \"rgb(127,246,88)\", \"rgb(82,246,103)\", \"rgb(48,239,130)\", \"rgb(29,223,163)\", \"rgb(26,199,194)\", \"rgb(35,171,216)\", \"rgb(54,140,225)\", \"rgb(76,110,219)\", \"rgb(96,84,200)\"], c = { text: \"\", prefixP: -s, skillI: 0, skillP: 0, direction: \"forward\", delay: a, step: g }; i() }; if ($(\"#jinrishici-sentence\")[0]) { binft(document.getElementById('jinrishici-sentence')); } // 浏览器搞笑标题 var OriginTitle = document.title; var titleTime; document.addEventListener('visibilitychange', function () { if (document.hidden) { $('[rel=\"icon\"]').attr('href', \"/funny.ico\"); document.title = '╭(°A°`)╮ 页面崩溃啦 ~'; clearTimeout(titleTime); } else { $('[rel=\"icon\"]').attr('href', \"/favicon.ico\"); document.title = '(ฅ>ω"},{"title":"","date":"2021-05-19T11:18:03.769Z","updated":"2021-05-19T11:18:03.769Z","comments":true,"path":"assets/js/vue.min.js","permalink":"http://yoursite.com/assets/js/vue.min.js","excerpt":"","text":"/*! * Vue.js v2.3.2 * (c) 2014-2017 Evan You * Released under the MIT License. */ !function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):e.Vue=t()}(this,function(){\"use strict\";function e(e){return void 0===e||null===e}function t(e){return void 0!==e&&null!==e}function n(e){return!0===e}function r(e){return\"string\"==typeof e||\"number\"==typeof e}function i(e){return null!==e&&\"object\"==typeof e}function o(e){return\"[object Object]\"===Ai.call(e)}function a(e){return\"[object RegExp]\"===Ai.call(e)}function s(e){return null==e?\"\":\"object\"==typeof e?JSON.stringify(e,null,2):String(e)}function c(e){var t=parseFloat(e);return isNaN(t)?e:t}function u(e,t){for(var n=Object.create(null),r=e.split(\",\"),i=0;i-1)return e.splice(n,1)}}function f(e,t){return Si.call(e,t)}function p(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}function d(e,t){function n(n){var r=arguments.length;return r?r>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n}function v(e,t){t=t||0;for(var n=e.length-t,r=new Array(n);n--;)r[n]=e[n+t];return r}function h(e,t){for(var n in t)e[n]=t[n];return e}function m(e){for(var t={},n=0;n"}],"posts":[{"title":"webpack4打包","slug":"code/webpack4","date":"2021-12-17T09:57:00.000Z","updated":"2021-12-17T12:48:30.073Z","comments":true,"path":"2021/12/17/code/webpack4/","link":"","permalink":"http://yoursite.com/2021/12/17/code/webpack4/","excerpt":"","text":"因打包需要 vue2 所以用的 webpack4 打包配置 依赖安装npm i -D webpack@4.14.0 webpack-cli@4.9.1 配置文件分析externals 外部扩展element-ui 配置参考 const path = require(&quot;path&quot;); const BundleAnalyzerPlugin = require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin; const UglifyJsPlugin = require(&#39;uglifyjs-webpack-plugin&#39;); const resolve = (dir) =&gt; &#123; return path.join(__dirname, dir) &#125; module.exports=&#123; mode: &#39;production&#39;, // 指定是本地开发还是线上环境 entry:&#39;path/a&#39;|[&#123;a:&#39;page/*/1&#39;&#125;,&#123;b:&#39;page/*/2&#39;&#125;], // 入口js文件 一个或多个都行 output:&#123; // 导出配置 path: path.resolve(process.cwd(), &#39;./lib&#39;), // 导出路径设置 filename: &#39;[name].js&#39;, //多个的时候可以设置name为文件名 chunkFilename: &#39;[id].js&#39;, libraryExport: &#39;default&#39;, libraryTarget: &#39;commonjs2&#39; &#125;, resolve: &#123; //模块解析 extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;], //解析那些文件 alias: &#123;//设置路径别名 &quot;~&quot;: resolve(&quot;../&quot;), &#125;, modules: [&#39;node_modules&#39;] // 指定模块文件夹名称 &#125;, externals: &#123; // 将依赖包通过外部引用形式加载进来，减小包体积 vue: &#39;vue&#39;, &#125;, performance: &#123; // 性能关闭提示 hints: false &#125;, stats: &#39;none&#39;, // 统计，不显示统计信息 optimization: &#123; // 不压缩代码 minimize: false &#125;, module: &#123; // 解析不同的文件内容 rules: [ &#123; test: /\\.(jsx?|babel|es6)$/, include: process.cwd(), // exclude: config.jsexclude,// 排除指定文件 loader: &#39;babel-loader&#39; &#125;, ] &#125;, plugins: [ //以各种方式自定义webpack构建过程 new UglifyJsPlugin(&#123; // 压缩插件 parallel: true, sourceMap: false &#125;), new BundleAnalyzerPlugin(&#123; //分析包大小占比插件 analyzerPort: 8081 &#125;) ] &#125;","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"NPM包开发","slug":"code/npm","date":"2021-06-11T05:36:00.000Z","updated":"2021-12-17T12:58:16.658Z","comments":true,"path":"2021/06/11/code/npm/","link":"","permalink":"http://yoursite.com/2021/06/11/code/npm/","excerpt":"","text":"相关资料eslint 文档 规范一般来说根目录下会存在这么几个文件夹： packages: 多组件源文件src：源码源文件入口文件。lib：打包后的插件node_modules：npm 依赖文件。bin：二进制可执行文件。tests：单元测试或集成测试文件。docs：文档、开发手册。examples：示例代码或项目。 至于 npm publish 出来的文件包含上述哪些，你即可以在 package.json 的 files 里配置包含哪些，也可以在 .npmignore 里配置忽略哪些。 须知package.json 字段以下是和发布到 npm 有密切关系的字段(但不仅限于这些字段) name：库的名字。version：库的版本号，发布的时候读取的就是这个字段。main: 指定默认文件author：库作者，会在 npm 网站库首页显示。license：开源证书，会在 npm 网站库首页显示。repository：代码库地址，会在 npm 网站库首页显示。homepage：库的主页地址，会在 npm 网站库首页显示。dependencies：你的库依赖的其他库，在开发者 install 你的库的时候会一并下载。 &#123; &quot;name&quot;: &quot;@bzvue/beizeng-ui&quot;, // 库的名字 &quot;version&quot;: &quot;0.0.7&quot;, // 库的版本号，发布的时候读取的就是这个字段 每次发布版本号必须更新 &quot;main&quot;: &quot;lib/index.common.min.js&quot;, //指定默认文件 &quot;author&quot;: &quot;doudou&quot;, //库作者，会在 npm 网站库首页显示。 &quot;files&quot;: [ // 发布时上传的文件或文件夹 &quot;lib&quot; ], &quot;keywords&quot;: [ // 关键词 &quot;vue&quot;, &quot;components&quot; ], &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vue-cli-service serve&quot;, &quot;lint&quot;: &quot;vue-cli-service lint --fix&quot;, &quot;build:lib&quot;: &quot;webpack --config ./build/webpack.common.js&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;core-js&quot;: &quot;^3.6.5&quot;, &quot;vue&quot;: &quot;^2.6.11&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.14.0&quot;, &quot;webpack-cli&quot;: &quot;^4.9.1&quot; &#125; &#125; 私有仓库scoped 库如果你的库是公开库，则直接 npm publish 就可以了（对了 publish 前记得 login 噢~）。 如果你的库名是 @name/subname，说明你的库是 scoped，那么你还要做这些事情： 登录到 npm 网站，建立一个 @name 的组织：https://www.npmjs.com/org/create （填写 organization name 的时候 @ 符号不用填），付费还是公开按需自己的需要。首次发布，如果不先建立，是发不上去的，会报 Scope not found。 如果你的库名是 @name/subname，且按公开库发布，在运行 npm 发布命令时要加参数：npm publis –access public 第二步中如果不加参数，请在 package.json 中加上如下字段： {“publishConfig”: {“access”: “public”}}","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Nestjs学习","slug":"code/nest","date":"2021-05-31T02:00:00.000Z","updated":"2021-12-17T12:48:30.073Z","comments":true,"path":"2021/05/31/code/nest/","link":"","permalink":"http://yoursite.com/2021/05/31/code/nest/","excerpt":"","text":"入门中文文档npm i -g @nestjs/clinest new project-name 开发常见跨域: 在main.ts文件中 app.enableCors();初始化：nest g res filter-name [folder-name]生成基本的代码结构 项目配置规范接口使用全局过滤，过滤错误结果 nest g f filter-name [folder-name] 生成全局过滤文件 import &#123; ExceptionFilter, Catch, ArgumentsHost, HttpException, Logger, HttpStatus &#125; from &#39;@nestjs/common&#39;; import &#123; Request, Response &#125; from &#39;express&#39;; @Catch(HttpException) export class HttpExceptionFilter implements ExceptionFilter &#123; catch(exception: HttpException, host: ArgumentsHost) &#123; const ctx = host.switchToHttp(); const response = ctx.getResponse&lt;Response&gt;(); const request = ctx.getRequest&lt;Request&gt;(); // const status = exception.getStatus(); const message = exception.message; Logger.log(&#39;错误提示&#39;, message); const status = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR; // 设置返回的状态码、请求头、发送错误信息 response.status(status); response.header(&#39;Content-Type&#39;, &#39;application/json; charset=utf-8&#39;); response.send(&#123; data: message, // 获取全部的错误信息 message: &#39;请求失败&#39;, code: 1, // 自定义code url: request.originalUrl, // 错误的url地址 &#125;); &#125; &#125; 使用全局拦截，拦截正确结果 nest g in filter-name [folder-name] 生成全局拦截文件 import &#123; Injectable, NestInterceptor, CallHandler, ExecutionContext, &#125; from &#39;@nestjs/common&#39;; import &#123; map &#125; from &#39;rxjs/operators&#39;; import &#123; Observable &#125; from &#39;rxjs&#39;; interface Response&lt;T&gt; &#123; data: T; code?:number, &#125; @Injectable() export class TransformInterceptor&lt;T&gt; implements NestInterceptor&lt;T, Response&lt;T&gt;&gt; &#123; intercept( context: ExecutionContext, next: CallHandler&lt;T&gt;, ): Observable&lt;Response&lt;T&gt;&gt; &#123; return next.handle().pipe( map((data,...params) =&gt; &#123; // console.log(params); return &#123; data, code: 0, message: &#39;请求成功&#39;, &#125;; &#125;), ); &#125; &#125; 最后在main.ts中进行引入注入 // 引用全局过滤 app.useGlobalFilters(new HttpExceptionFilter()); //拦截器 app.useGlobalInterceptors(new TransformInterceptor()); 数据库引入在 app.module.ts 中进行注入 import &#123; Module &#125; from &#39;@nestjs/common&#39;; import &#123; AppController &#125; from &#39;./app.controller&#39;; import &#123; MongooseModule &#125; from &#39;@nestjs/mongoose&#39;; import &#123; PageModule &#125; from &#39;./page/page.module&#39;; @Module(&#123; imports: [MongooseModule.forRoot(&#39;mongodb://localhost/nest&#39;), PageModule], controllers: [AppController], providers: [], &#125;) export class AppModule &#123; &#125; 在schema.ts文件中设置模版类型 import &#123; Prop, Schema, SchemaFactory &#125; from &#39;@nestjs/mongoose&#39;; import &#123; Document &#125; from &#39;mongoose&#39;; export type PageDocument = Page &amp; Document; @Schema() export class Page extends Document &#123; @Prop(&#123;type:Object,default:null&#125;) json: object; @Prop(&#123;default:&#39;&#39;&#125;) js: string; @Prop(&#123;default:&#39;&#39;&#125;) html: string; @Prop(&#123;default:&#39;&#39;&#125;) script: string; @Prop(&#123;default:&#39;&#39;&#125;) name: string; @Prop(&#123;default:[]&#125;) drawingItems: Array&lt;any&gt;; @Prop(&#123;type:Object,default:null&#125;) formConf: object; &#125; export const Pagechema = SchemaFactory.createForClass(Page); 最后在service.ts文件中进行注入和操作 import &#123; Injectable &#125; from &#39;@nestjs/common&#39;; import &#123; CreatePageDto &#125; from &#39;./dto/create-page.dto&#39;; import &#123; UpdatePageDto &#125; from &#39;./dto/update-page.dto&#39;; import &#123; InjectModel &#125; from &#39;@nestjs/mongoose&#39;; import &#123; Model &#125; from &#39;mongoose&#39;; import &#123; Page, PageDocument &#125; from &#39;./schemas/page.schema&#39;; @Injectable() export class PageService &#123; constructor(@InjectModel(Page.name) private readonly pageModel: Model&lt;PageDocument&gt;) &#123; &#125; async create(createPage: CreatePageDto): Promise&lt;Page&gt; &#123; const createdPage = new this.pageModel(createPage); return createdPage.save(); &#125; async findAll(): Promise&lt;Page[]&gt; &#123; return this.pageModel.find().exec() &#125; findOne(id: string) &#123; return this.pageModel.findOne(&#123; _id: id &#125;,&#123;__v:0&#125;); &#125; update(id: string, updatePageDto: UpdatePageDto) &#123; return this.pageModel.updateOne(&#123; _id: id &#125;,updatePageDto); &#125; async remove(id: string) &#123; await this.pageModel.remove(&#123; _id: id &#125;); return &#39;删除成功&#39; &#125; &#125; 中间件生成中间件文件 nest g mi filter-name [folder-name] 可用两种中间件形式，类或者函数 import &#123; Injectable, NestMiddleware &#125; from &#39;@nestjs/common&#39;; import &#123; Request, Response, NextFunction &#125; from &#39;express&#39;; @Injectable() export class LoggerMiddleware implements NestMiddleware &#123; use(req: Request, res: Response, next: NextFunction) &#123; // console.log(&quot;Request ......&quot;,req); next() &#125; &#125; // 函数式中间件 export function logger(req, res, next) &#123; next(); &#125;; main.ts中注入中间件 import &#123; logger &#125; from &#39;./app.middleware&#39;; // 引用中间件 app.use(logger);","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"后台","slug":"后台","permalink":"http://yoursite.com/tags/%E5%90%8E%E5%8F%B0/"}]},{"title":"Docker应用","slug":"code/docker","date":"2021-05-02T10:00:00.000Z","updated":"2021-05-19T11:18:03.694Z","comments":true,"path":"2021/05/02/code/docker/","link":"","permalink":"http://yoursite.com/2021/05/02/code/docker/","excerpt":"","text":"基本命令docker version检查docker的版本，这样可以用来确认docker服务在运行并可通过客户端链接。docker search 镜像名字搜索可用的docker镜像docker pull 镜像名字通过docker命令下载tutorial镜像。执行pull命令的时候要写完整的名字，比如”learn/tutorial”。docker run learn/tutorial echo &quot;hello word&quot;在docker容器中运行hello world!docker run命令有两个参数，一个是镜像名，一个是要在镜像中运行的命令。下一步我们要做的事情是在容器里面安装一个简单的程序(ping)。我们之前下载的tutorial镜像是基于ubuntu的，所以你可以使用ubuntu的apt-get命令来安装ping程序： apt-get install -y ping。 备注：apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失。在learn/tutorial镜像里面安装ping程序。在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。docker run learn/tutorial apt-get install -y ping docker ps -l查看所有正在运行中的容器列表 docker inspect 容器id前几位使用 docker inspect命令我们可以查看更详细的关于某一个容器的信息。docker commit 698 learn/ping保存对容器的修改当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。docker中保存状态的过程称之为committing，它保存的新旧状态之间的区别，从而产生一个新的版本。 目标：首先使用 docker ps -l命令获得安装完ping命令之后容器的id。然后把这个镜像保存为learn/ping。 提示： 运行docker commit，可以查看该命令的参数列表。 你需要指定要提交保存容器的ID。(译者按：通过docker ps -l 命令获得) 无需拷贝完整的id，通常来讲最开始的三至四个字母即可区分。（译者按：非常类似git里面的版本号) 执行完docker commit命令之后，会返回新版本镜像的id号。 运行新的镜像ok，到现在为止，你已经建立了一个完整的、自成体系的docker环境，并且安装了ping命令在里面。它可以在任何支持docker环境的系统中运行啦！ 正确的命令： docker run lean/ping ping www.google.com docker images 命令可以列出所有安装过的镜像。 docker push 可以将某一个镜像发布到官方网站。 你只能将镜像发布到自己的空间下面。这个模拟器登录的是learn帐号。 预期的命令：docker push learn/pingdocker container prune删除所有的容器docker image prunesudo docker rmi $(docker images -q)删除所有的镜像","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"系统","slug":"系统","permalink":"http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F/"}]},{"title":"mac 安装配置","slug":"code/mac","date":"2020-11-16T08:40:00.000Z","updated":"2021-05-19T11:18:03.696Z","comments":true,"path":"2020/11/16/code/mac/","link":"","permalink":"http://yoursite.com/2020/11/16/code/mac/","excerpt":"","text":"环境建立用户目录下建个个人文件，里面放所有关于开发的东西。sudo chmod -R 777 文件名 (对该文件夹增加最高权限，省的以后出现各种权限问题。nvm 用git下载下来，然后在目录里，","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"系统","slug":"系统","permalink":"http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F/"}]},{"title":"Linux","slug":"code/linux","date":"2020-04-17T13:14:00.000Z","updated":"2021-05-19T11:18:03.696Z","comments":true,"path":"2020/04/17/code/linux/","link":"","permalink":"http://yoursite.com/2020/04/17/code/linux/","excerpt":"","text":"基础操作显示cpu架构信息 [xxx@localhost ~]$ lscpu Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian CPU(s): 4 #总处理器核心数量 On-line CPU(s) list: 0-3 Thread(s) per core: 1 #每个核心支持的线程数量。1表示只支持一个线程，即不支持超线程 Core(s) per socket: 1 #每个处理器的核心数量 Socket(s): 4 #处理器数量 NUMA node(s): 1 Vendor ID: GenuineIntel CPU family: 6 Model: 63 Stepping: 0 CPU MHz: 2599.998 BogoMIPS: 5199.99 Hypervisor vendor: VMware #管理程序供应商 Virtualization type: full L1d cache: 32K L1i cache: 32K L2 cache: 256K L3 cache: 30720K NUMA node0 CPU(s): 0-3 查看安装位置ps -ef | grep nginx 查看nginx配置文件位置nginx -t 查看端口占用netstat -ntlpnvm安装wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.35.3/install.sh | bash安装后设置快捷方式source ~/.bashrc列出可安装目录，LTS为稳定版nvm ls-remote git安装传送门 github下载指定版本tar.gz文件并发送至服务器/home文件夹解压文件 tar -zxvf git-2.22.0.tar.gzcd git-2.22.0安装编译源码相关依赖yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker安装编译源码所需依赖的时候，yum自动帮你安装了git，这时候你需要先卸载这个旧版的git。yum -y remove git编译git源码make prefix=/home/git all安装git至/home/git-version路径make prefix=/home/git-version install配置环境变量vi /etc/profile 在底部加上export PATH=$PATH:/usr/local/git/bin( 输入 :wq! 保存修改)刷新环境变量source /etc/profile查看Git是否安装完成git --version至此，从github上下载最新的源码编译后安装git完成。 PM2 常用命令pm2常用命令记录 $ pm2 start app.js # 启动app.js应用程序 $ pm2 start app.js -i 4 # cluster mode 模式启动4个app.js的应用实例 4个应用程序会自动进行负载均衡 $ pm2 start app.js --name=&quot;api&quot; # 启动应用程序并命名为 &quot;api&quot; $ pm2 start app.js --watch # 当文件变化时自动重启应用 $ pm2 start script.sh # 启动 bash 脚本 $ pm2 list # 列表 PM2 启动的所有的应用程序 $ pm2 monit # 显示每个应用程序的CPU和内存占用情况 $ pm2 show [app-name] # 显示应用程序的所有信息 $ pm2 logs # 显示所有应用程序的日志 $ pm2 logs [app-name] # 显示指定应用程序的日志 $ pm2 flush # 清空所有日志文件 $ pm2 stop all # 停止所有的应用程序 $ pm2 stop 0 # 停止 id为 0的指定应用程序 $ pm2 restart all # 重启所有应用 $ pm2 reload all # 重启 cluster mode下的所有应用 $ pm2 gracefulReload all # Graceful reload all apps in cluster mode $ pm2 delete all # 关闭并删除所有应用 $ pm2 delete 0 # 删除指定应用 id 0 $ pm2 scale api 10 # 把名字叫api的应用扩展到10个实例 $ pm2 reset [app-name] # 重置重启数量 $ pm2 startup # 创建开机自启动命令 $ pm2 save # 保存当前应用列表 $ pm2 resurrect # 重新加载保存的应用列表 $ pm2 update # Save processes, kill PM2 and restore processes $ pm2 generate # Generate a sample json configuration file pm2文档地址：http://pm2.keymetrics.io/docs/usage/quick-start/","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"系统","slug":"系统","permalink":"http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"基金总结","slug":"learn/found_note","date":"2020-04-06T07:02:00.000Z","updated":"2021-05-19T11:18:03.700Z","comments":true,"path":"2020/04/06/learn/found_note/","link":"","permalink":"http://yoursite.com/2020/04/06/learn/found_note/","excerpt":"","text":"注意周四下午三点后申购的基金会在下周一早上到账，所以一定避免在周四下午三点后到周日白天时间内申购基金。T+0是赎回当天就可到账T+1是一天后到账投资要纯的，确定基金把钱用在哪里了，不用混合的。确定基金的主营方向才能确定要把该基金放在什么定位。投资要多种类选择投资，不能把鸡蛋放在一个篮子里。凭票国债是中老年人最合适的投资方式。同时买股票债券一定小于单独买债券或者股票。指数型基金就是股票基金。 资金存放资金先放到华泰证券天天发基金，晚上会自动进入天天发基金获取收益早上自动出来，收益率相当于货基。 基金判断好基金需要看公司累计净值，单位净值是不包含分红的净值，累计净值是包含分红的净值。分不分红与基金好坏没有关系，净值高低与基金好坏没有关系。 风险对冲关系股票——房子存款——债券美元——黄金美元——日元美元——石油美元——比特币 股票代码分类1、创业板 创业板的代码是抄300打头的股票代码；2、沪市A股 沪市A股的代码是以600、601或603打头；3、沪市B股 沪市B股的代码是以900打头；度4、深市A股 深市A股的代码是以000打头；5、中小板 中小板的代码是002打头；6、深圳B股 深圳B股的代码是以200打头；7、新股申购 沪市新股申购的代码是以730打头 深市问新股申购的代码与深市股票买卖代码一样；8、配股代码 沪市以700打头，深市以080打头 权证，沪市是580打头 深市是031打头。9、 400开头的股票是三板市场答股票。 基金名字基金名字=基金公司名字+基金特点+基金投资范围正常基金 例：国联安+中证半导体+ETF联接A吹牛基金 例：国联安+全球视野+混合配置 基金费用支出费用=基金管理费+基金托管费+销售管理费 基金分红方式1.现金分红2.红利再投资 一线大公司的基金天弘，华夏，易方达，南方，工银瑞信，建信，博时，嘉实，招商，广发，汇添富，鹏华，富国，华宝兴业 货基（建议持有，收益4%左右）最稳定的基金，比银行活期存款高。 货基后面的字母A 代表一千起买B 代表五百万起买ETF 场内余额宝，所有货币中交易最方便费率最低的基金，但是基金收益太低（收佣金的不要） 最大三个货基ETF：华宝添益，银华日利，理财金H 债基（建议持有，纯债基金8%左右）时长分类：短债基金，中短债基金，长期债券基金。股票分类：债券指数基金：不建议选择。二级债基：买二级市场股票的债券基金。（持有股票越多风险越高）。一级债基：不能买二级股票债券基金，打新股。（风险比二级低）。纯债基金：不碰任何股票的基金。（建议持有）转债基金：投资可转债基金。（风险远高于纯债与一级债基）靠谱债券公司：汇添富，天弘，华安，工银，鹏华，广发，南方，银华，长盛，华夏。 债基后面所跟字母费用0.2%-0.6%左右。A类收取申赎费用。（一次性收取）（最少放一年的）B类不另外扣除申赎费用，而是和管理费，托管费等折算到基金净值中提前扣除了。（后端一次收取或者逐年收取）C类不收取申赎费，取销售服务费。（按年逐渐收）（试水两个月） 选择方式靠谱品牌公司+长期纯债+近三年收益+倒序排列+前三十名。 1.剔除投资可转债的基金。 2.剔除小公司的基金。 3.剔除规模大的基金。（基金规模超过二十亿） 4.剔除同一基金公司旗下非王牌基金。 5.选择综合费率最低的。 6.基金成立时间较长+基金经理年纪较大+基金经理管理时间较长的。 定期开放式债券基金（定开债）优选时间：半年-三年期限封闭期，开放几个月时间集中申购或者赎回。选择：纯债基金+杠杆率低于160%+封闭期一年。 国债逆回购机构缺钱用手中的债券卖给散户做抵押给利息，稳定收益高点。买国债逆回购时要点击卖出；卖国债逆回购时要点击买入。深市国债逆回购价格=100元*10份（最低）=1000元沪市国债逆回购10万增减有手续费的，天数越多的话相对比例的手续越低。逆回购利润为：购入金额 * 利率（例0.55）/ 360 * 持有天数时机：参考Shibor利率变化。参考数据：集思录 混合型基金（不建议）不如自己按照个人比例买入股基债基偏股混合型基金即为股票基金。偏债混合基金类似于二级债基，低于20%的资金去投股票。平衡性基金：风险对冲，债券与股市各自参半。灵活型基金：基金经理按照各自的经验去买入卖出股市或者基金。 主动性股票基金（风险最高，收益最高）选择大公司，他们的研究团队更大更专业，优质基多而且公司资源雄厚。 五星好评大公司： 南方基金，嘉实基金，富国基金，银华基金，华安基金，汇添富基金，兴全基金。 基金超过一千亿的公司： 天弘基金，工银瑞信，易方达基金，博时基金，招商基金，华夏基金，建信基金，中银基金，鹏华基金，广发基金，华宝兴业，兴业基金管理有限公司，上投摩根，大成基金。 选择靠谱的基金经理：基金经理的基本背景：年龄35+，学历硕博海归，履历从业时间长，管理该基金时间长等。 基金经理的操盘风格： 持仓频率适宜 基金换手率低于百分之五十为低； 基金换手率在50%到200%为适中； 基金换手率高于200%为高。 基金评级： 权威评级公司——晨星公司里面有基金风格箱，天天基金网也有，可以判断该基金经理的操作风格。 晨星风格箱： 价值型股票（白马股）：业绩稳定分红能力强，都知道的好股票。规模比较大，业绩增速慢，挣钱慢。 成长性基金（黑马股）：基金规模小，成立时间短，业绩一般，分红少，未来预期成长空间大。 平衡性基金：业绩稳定看不出来未来业绩如何。 小型价值股价值最高。 基金经理的业绩参考： 基金创立时间长，三五年以上的，相对选择成立时间长的。 基金业绩稳定，无论外部环境如何依然能够有很好的业绩表现。过去五年内都在同类基金百分之二十以内的为优秀。天天基金网查看同类基金走势来判断。 基金业绩指数基金业绩评价基准（β系数）货币型基金——定期存款利率股票型基金——大盘走势指数基金——所跟踪的指数大盘风格基金——80%沪深300指数+20%上证国债指数医药行业类基金——80%中证医药卫生指数+20%中证国债指数高β系数的股票适合激进型投资者和大牛市。低β系数适合稳健性投资者和熊市。 超额收益（α系数） (常用)顾名思义为超出业界评价基准的多出收益，系数越大说明基金经理水平高能力强。α系数=真实收益系数-β系数 R平方 (常用)R平方的数值越高α系数与β系数的可信度越高。（例100为百分百可信） 夏普比率 (常用)夏普比率 = ( 基金回报率 - 市场无风险回报率 ) / 标准差夏普指数越高说明基金越靠谱收益越高。 数星星(常用)晨星退出的基金星级评价五年评级的五星好评的基金才是好基金 标准差标准差所测出的是基金的全部风险。 特雷诺指数夏普比率 = ( 基金回报率 - 市场无风险回报率 ) / β系数反应基金承担单位系统风险所获得的超额收益。指数越大则承担风险所获得的超额收益越高。 基金规模小盘 3亿以下（不要碰）中小盘 10-20亿大盘股基金 30-100亿巨无霸基金 超过100亿（不要碰） 基金成本常见赎回费0.5%；部分第一年赎回0.25%，第二年免收赎回费。同等条件下选择阶梯收费的基金。 指数股票基金 （买它买它）主动性基金经理 1.人才流失严重 2.基金经营相关人员很多故意坑害散户（老鼠仓）（郑拓）指数型基金就不用承担人力风险，但是其实是赌国运。而且比者其他所有基金都要便宜，申购或者赎回费率低。可靠性优于主动股票基金，绝不减仓，无论什么事情都是满仓。巴菲特强力建议的基金。 股票指数上证指数（上证综指）： 上海交易是主板市场大型公司上市比例大，国营企业大都选择这里。该指数表明上海所有股票的总体水平。但是其中中石油占上证指数市值的25%,所以中石油的股价非常影响上证指数 深证综指：深圳全部股票的总市值的总体水平。中小板与创业板是最坑的，也是最暴涨的。上交所指数 深交所指数 中证所指数 成分指数根据科学客观的选样方法挑选出的样本股所构成的指数。（只考虑流通股） 深成指集合了深圳市场500只大中小股票，偏小股的股票指数。主要代表小盘股。 深证100指数由深圳证券市场流通市值最大成交最活跃的100只成分股所编制的股票指数。主要代表大盘股。 上证50指数（精英中的精英）从所有上交所股票中抽取规模最大流动性最好的50只股票，反应上海市场绩优大盘股的整体状况。其中一半以上都是金融股，还有就是两桶油，所以这两个最能影响该指数。 上证180指数 （上交所优质股票）从所有上交所股票中抽取最具市场代表性的180只样本股，最能代表上交所核心优质上市公司的指数。 沪深300指数（大中盘股的精华）从沪深两市综合选取300只股票，反映沪深两市大盘整体面貌的指数。大盘股发力该指数会大涨。 中证500指数（小盘股的精华）首先排除沪深300指数内的股票，剩下股票中前300的也剔除掉，交易最不活跃的20%剔除掉，选取市值排行最高的500个。小盘股发力了，该指数会大涨。 增强型指数基金（不推荐）基金经理可以在指数范围内调配基金比例的增强型指数基金，有风险跑不过大盘。 大数据指数基金（不推荐）很多大数据基金更名为混合基金。腾安100大数据指数，半年变动一次（腾讯）百发100大数据指数，每月变动一次（百度）博时淘金100大数据指数，每月变动一次（阿里）新浪i100大数据指数，每月变动一次（新浪）中证银联智慧大数据，每月变动一次（银联）中证银行智策大数据，每月变动一次（银联）中证银行智策消费大数据，每月变动一次（银联）360互联+大数据指数，每月变动一次（360） 挑选指数基金主要挑选跟踪指数误差最小的那个基金，可以在天天基金网查看跟踪的指数基金以及误差。跟踪误差超过3%即为垃圾基金。成本最低的是场内ETF指数基金。规模不可太小，规模大的基金对申购赎回的影响很小。选择老基金购买，新基金的建仓可能还没有完成跟踪误差可能会变大。 ETF基金（指数基金中的王者）可以在交易所上市交易的基金份额可变的开放式基金，可以随意交易。既有指数基金的优势又交易方便。资金效率高：满仓操作，资金利用效率高，申购赎回方便。投资门槛低：一手基金购买便宜。管理费率低：因为不用基金经理操心所以管理费很低。套利玩法：套利玩法可以带来超额收益。ETF基金一级市场净值 = 基金批发价ETF基金二级市场价格 = 基金零售价零售价 &lt; 批发价为 折价零售价 &gt; 批发价为 溢价实时参考净值（净值估算）：估算当下基金的具体净值。如果净值估算高就快卖，如果净值估算低就赶快买入。优势：便宜，灵活。劣势：操作复杂，无法定投，必须在股市开盘时间操作。 ETF联接基金ETF联接基金仓位配比：90%以上资金必须去对应的ETF基金。费用比EFT基金高了一点但是还是比指数基金低。优势：持有成本比普通指数基金低；可自动设置定投计划。 套利套利需要根据公司的具体市值来判断是否溢价。短期内低价买入高价买入，主要选择ETF基金，资金流动性强便于套利。不过需要注意算利方式是算尾不算头才可套利，算头不算尾就没必要套利了。季末或者年末市场资金短缺适合抄底ETF，但还是依据具体情况。依据数值Shibor(国内各大银行之间借钱的利率)，因为政府规定银行资本CAR不得低于百分之八，政府会在季末去审查审查，放贷过度的银行缺钱了就会去借钱，借钱的银行多了这个利率就会升高。该指标是个非常重要的经济指标。普通在1/2%左右。参考数据：集思录ETF基金中查看溢价率：&gt; 3% 谨慎交易 &gt; 5% 暂停交易 &gt; 10% 赶快卖出 反之折价亦然 基金选择规模&gt;2亿最好10亿以上。 ETF基金vsLOF基金区别ETF基金全是指数基金；LOF基金种类多，货币，债券，指数等都可。资金门槛低。 LOF基金上市型开放式基金，是中国市场自主创造的一种基金品种。同时具备了ETF基金和ETF联接基金的优点，既可以在二级市场交易又可以在一级市场玩折价溢价。名字：最后有一个括号里面是LOF。","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基金","slug":"基金","permalink":"http://yoursite.com/tags/%E5%9F%BA%E9%87%91/"}]},{"title":"基金入门","slug":"learn/found","date":"2020-04-05T07:13:00.000Z","updated":"2021-05-19T11:18:03.699Z","comments":true,"path":"2020/04/05/learn/found/","link":"","permalink":"http://yoursite.com/2020/04/05/learn/found/","excerpt":"","text":"相关资源B站力哥讲财经知乎基金专栏 了解基金股票：代表一种股权（拥有权），享受经营的分红，收益较高，同时承担经营的风险，风险较大 债券：代表一种债权，提前约定收益，收益较低，利息不受经营的影响，风险较小 基金：代表一种委托关系，委托专业机构帮你理财，收益受专业机构的理财能力影响，一般而言，收益小于股票，大于债券，相对应，风险小于股票，大于债券 银行理财产品：包含债券和基金以及其他，具体是啥看情况。 基金，是你让专业人士帮你去投资，因为专业人士一般而言都挺专业的（不然他也不叫专业人士），并且基金投资的时候，会进行分散投资（投多个股票或者股票、债券结合等），因此风险相对而言就比股票小。 而基金跟债券相比，我记得教科书上写的是，基金风险大于债券。当然，一般而言是这样，但其实也是得看基金类型的，这个后面再详细讲，只要记住基金和债券风险都要比股票小就行了。 基金快餐知识点基金入门第一章：基金中的名词如果想真正懂一点点基金知识，了解一些基本的基金名词是有必要的，不然就跟彩票买随机号码一样了。话不多说，介绍一点基金常识名词。 认购：该基金首次发行基金产品，投资者参与基金产品的行为，称为认购。 对应关注点：（这种基金产品应该关注该基金公司的情况，如公司规模，公司的其他基金的表现。） 申购：基金已经发布产品，继续向投资者开放购买，投资者参与基金产品的行为，称为申购。 对应关注点：（这种产品主要关注该基金产品往期的表现，近三个月、半年、一年等的收益曲线等） 赎回：投资者向基金公司拿回之前的投资金额，结束和基金公司签订的合同，拿回投资资金，称为赎回。 对应关注点：（判断之前的收益是否已经达到自己的预期收益，或关注基金经理的操作是否符合当初的承诺，即分析该基金经理是否靠谱，如果感觉不靠谱也可以赎回自己的资金，转投其他的产品。） 分红：在基金产品运作过程中，基金公司会将获得投资收益后，以分红的形式分配给投资者。 对应操作：①收回分红，干其他的事。②红利再投资。 基金净值：是指当前的基金总资产除以基金总份额，其计算表公式为：基金单位净值=总净资产/基金份额。 基金单位累计净值：基金单位净值与基金成立后历次累计单位派息金额的总和，反映该基金自成立以来的所有收益的数据。 基金单位累计净值=基金单位净值+基金历史上累计单位派息金额（基金历史上所有分红派息的总额/基金总份额） ps：最后两个概念不明白也没关系，没必要一次性死记硬背这些概念，先有个大概印象，后面实际操作的时候，自然就会明白了。 基金入门第二章：基金投资的流程（上）基金的购买渠道：我们需要知道，在哪里可以购买基金（博主也是萌新，暂且现在”支付宝/蚂蚁金服”上混混经验吧）。 基金投资的风险： ps：这里不要一看到这么多风险，就害怕了，博主觉得简单的来说，市场风险就是市场环境现在怎么样，适不适合投资；管理风险和技术风险的话，新手就选大一点的基金产品，不要搞些小众产品。重要的是投资习惯，投资基金的话心态要好，不要看着有些基金有些小波动，就生怕亏钱了，基金是一种长期理财的工具，钱投在里面，要想赚取稳定的收益，还是得看长期，不要在意短期的市场波动。 基金投资者等级： 不用多说，博主也是初级小菜鸟级别的。个人觉得年轻人要学会攒钱，攒钱，攒钱，前面三个词不要关注钱，重要的是攒、攒、攒，不要把工资都吃喝拉撒玩用光了，抽出工资的一小部分，长期积累，积少成多。 基金投资的核心原则： ps：博主的理解就是，选基金的时候，不要选那种近期排名前几的太火爆的基金，这个跟学习工作不一样，不用争第一，排名靠前就行了。同时这里也提到，要放眼长期，资金要能长期存在里面，投资几天几周的这种，既花时间、又不一定获得收益。 基金入门第二章：基金投资的流程（下）正确的投资流程： 小白选手也不可能一下子懂这么多，太繁琐的流程，估计还没学会，就已经放弃了，这里简单点：了解市场环境、选一两只合适的基金、投资自己的一小部分钱、合适的时候(觉得收益满意了)收回。 下面是几个详细的流程： 简单的说：弄清楚你的自身情况，和你用来投资的这部分钱，大概投资多久。 基金相关主体（1）基金管理公司，就是负责管理基金的公司，他们的工作包括发起设立基金，进行基金运作，帮助投资者获得收益。一个基金管理公司，可以管理多个基金（大点的基金公司，基本上都是好几十个）。 （2）投资者投资于基金，一个投资者可以同时投资于多个（没有限制，只要你钱多就行）基金。 当投资者投资了某个基金管理公司旗下的基金时，其实就相当于投资者与该基金公司签订了一份委托协议，即投资人委托基金管理公司进行投资。 （3）所谓“托管”，我们可以理解为托付保管，所以基金托管公司呢，其实就是被托付来保管基金资产的，他们的职责主要就是保管基金的资产，监督基金管理公司以及向监管机构出报告等等。 每个基金都由一个基金托管公司进行托管，这由基金管理公司委托基金托管公司进行的。 总之，你可以这么理解，你委托了张三（基金管理公司）帮你进行投资，但又害怕张三会贪污、暗箱操作，私吞财产等，所以你犹豫不决。 而这个时候，张三找来了李四（基金托管公司），由李四负责保管你投资张三的钱，并且帮你监督张三；而怎么进行投资则是张三做决定，李四不能干预。 你觉得，诶，这个点子不错啊！这样就解决了我对张三的不信任问题，但是李四是张三找来的，我怎么知道他是否可信？ 这你也不必太多担心，因为李四一般是由银行（中农工交建行等等）来担任，况且在他们俩之上，还有一些市场管理员（证监会等），专门来管理市场秩序的。 基金的进程为了更容易记住，我们不妨来坐下角色扮演： 鸡＝基金 鸡蛋＝基金收益 养鸡人＝基金管理公司 禽类市场管理员＝证监会 一只基的一生大概包括以下几个阶段： 1.产品设计——“养只什么鸡呢” 在这个阶段，养鸡人（基金管理人）主要是考虑“养只什么鸡好呢”的问题，他需要根据市场的需求、发展的规划等等去做决定，比如预测到接下来债市行情不错，那我可能就设计一只债券鸡。 2.证监会审批——“同意你养啦“ 养鸡人决定好养什么鸡后，需要跟市场管理员（证券会）申报，然后市场管理员会审核养鸡人的养鸡计划，只有市场管理员觉得没问题了，养鸡人才能开始养鸡。所以呀，养鸡不是你想养，想养就能养滴。至于什么情况下市场管理员会拒绝请求，我们就不需要关啦，反正跟我们投资人没太大关系。 3.确认发行——”我要开始养鸡啦“ 证券会审批通过后，基金管理公司就可以准备好发行计划了，包括什么时候卖，在哪里卖等等。 4.募集资金——“谁要买鸡啦喂” 正式发行后，就会进入募集资金的阶段，即我们常在各种基金公司网站常看到的这种： 这个时候类，其实就是养鸡人向大家宣布：“我要养鸡啦，养鸡一共需要5000块，谁出钱给我养鸡，养了生下的鸡蛋（基金收益）就按出资比例分给你啦～” 5.建仓封闭期——”买饲料中，请勿打扰“ 新基金资金募集结束后，会有一个短暂的封闭期，我们可以称之为建仓期。这段时间主要是给基金公司进行资金的清算和按照产品计划进行初步建仓用的。 就理解成是养鸡人去买小鸡啦、鸡饲料等等，做好养鸡前的准备工作就是了。 6.正式运作 经过了建仓封闭期后，就进入了正常运作的阶段了。这个时候基金就可以正常接受申购、赎回了。（当然封闭型基金是不接受申购的，不过现在封闭型基金较少，先忽略不计，后面讲到基金分类时我们再细说。） 7.清盘——“老子不玩了，把钱分了大家散伙把” 清盘，就是一个基金的死亡。 一听到“清盘”这个词，是不是容易联想到“破产”之类的。 其实并不是，所谓基金清盘，是指基金资产全部变现，将所得资金分给持有人。而清盘的一般原因就是，基金规模很小了，并且持有人也很少了，基金管理公司也不想再运作了，所以可以根据程序去申请清盘。 简单理解把，就是投资人把最开始众筹养鸡的钱陆陆续续赎回去了，并且参与众筹的人也剩没几个了，养鸡人觉得钱这么少，人也这么少，干脆不玩了，把剩下的钱按比例分了，大家散了把！ 当然，清盘是要经过达到一定要求，并且经由市场管理人同意才行啦！ 恩，一只基金的一生就是如此了： 产品设计——证监会审批——确认发行——公开发行（募集资金）——建仓期封闭——正式运作——清盘 基金分类首先，我们先界定下大的范围，即所谓的公募基金和私募基金。 所谓公和私，其实指的就是对公和对私，对公即对公众开放，公开发行，所有人都可以投资，一般买入门槛很低，一块钱甚至一分钱就可以投了。 对私，即对私人发行，不是所有人都可以买的，一般门槛比较高，几十万上百万起。 因为公募的范围更广，并且信息更加规范，透明，这个专题所讲的所有内容都针对公募基金。 界定完大范围后，我们开始来讲细的，一谈到基金分类，我们的教科书和百度都是这么说的： 嗯，没有错，很准确，很完整。但是我们需要记住这么多么？ 其实并不需要，我们来讲点实战用的，请打开天天基金网（国内比较权威的卖基金网站），可以看到如下表格 其实红框里面的类型，就是我们所需要知道的基金分类。 因此，我把第二章——基金的分类分成以下三个部分来写： 1.最基础的分类——按投资标的分类 2.QDII 、ETF、ETF联结、LOF傻傻分不清楚 3.其他补充：分级基金、保本基金、打新基金 最基础的分类——按投资标的分类我们在第一章，《基金是什么（1）——基金的本质》里已经说了，基金：代表一种委托关系，委托专业机构帮你理财。那当你把钱交到专业机构（其实就是基金管理公司）手里后，他们要帮你去理财，那他们总得去投资一些什么东西，这些东西就是我们所谓的投资标的物，投资标的包括股票、债券、票据等等，那么根据标的物的不同来分类，是基金分类中最常见也是最基础的一种。 不同的标的物，其代表的风险和收益，基本上能够比较容易识别，因此只要了解了这种基金分类方式，基本上可以应付50%的情况了。 按照投资标的的分类，基本上可以分这么几种：货币型基金、股票型基金、债券型基金、混合型基金和指数型基金 我们就按照天天基金的这个分类来讲—— （1）货币型基金 虽然天天基金网上没有，但我决定还是先从这个最基础的讲起。 所谓的货币型基金，我们来看度娘的解释： 其实不用记得太多，你就记得货币基金是一种收益较低（但比银行活期高得多，目前在一年2-3%收益率左右徘徊），风险也很低，而且很灵活（很多货币基金已经支持随存随取，1分起购了）的基金就可以了。 相信大部分人都买过了，因为余额宝的本质就是货币基金，现在市面上的各种宝宝型产品（汇添富现金宝、招商招钱宝等等）其实本质就是货币基金。 严格意义上将货币基金也有风险，但由于其投资的标的风险都较低，目前还未出现过亏损的情况，所以基本上我都是作为活期存款来替代使用了。 （2）股票型基金 所谓股票型基金，顾名思义，就是大部分资金（不能低于80%的仓位）投资于股票的基金。 当然，上市的股票太多，为了更加方便让投资选择基金，同时也是因为基金经理的擅长领域有所不同，一般的股票基金都会再进行主题细分。感受一下： 比如专门投资于医疗行业的 比如专门投资于沪港深主题的 股票型基金，因其投资标的是股票，因此收益和风险在各类基金中都是最高的。 （3）债券型基金 所谓债券型基金，就是大部分资金（80%以上）投资于债券的基金。不同于股票型基金，以投资的股票主题来命名，大部分债券型基金都会标明投资债券的品种，这是因为不同的债券所代表的收益和风险也是不同的，常见的包括信用债、可转债等等。相较于股票型基金的一目了然，债券型基金的名称看起来总让人有点摸不着头脑，这块会在进阶版细讲，这里不展开。 （4）混合型基金所谓混合型基金，就是个不伦不类的基金，怎么样都可以，它可以投资于货币工具、股票和债券等等，你记住它是个什么都可以投的基金就可以了。 （5）指数型基金上述的基金其实都蛮好解释，而这个指数型基金，需要花点功夫讲一讲。顾名思义，指数型基金，其实就是投资标的是指数的基金。但指数又是个什么东西呢？打个比喻，比如我们想了解中国人的财富情况，但是呢，中国那么多人，我要怎么去了解呢？那么我们可以这样，我们把中国富豪排名前100名的人找出来（利用胡润排行榜），并且计算出他们的财富平均值，然后我们把这个数命名未中国财富100指数，并用它来大致代表中国的财富情况。这样，我们通过每年去监控这个指数，就可以知道中国人的财富是增长还是减少。同时我们通过自己的财富增长去对比这个数，也就可以知道我们自己的财富增长，在中国人中，是属于快的还是慢的。这个比喻很不科学，不过大体可以代表指数的来源和作用。 我们常见的指数有沪深300指数，上证50指数，深圳50指数等等，其实就是选取了不同市场中具有代表性的n只股票，通过一些算法把它们编织成一个指数，来代表某个市场的表现。所以投资于指数的基金，本质上就是投资于这些指数所包含的股票的基金。 因此，指数型基金的表现，基本上就是与该指数的表现一致。比如沪深300指数基金，其2016年的收益走势基本上与沪深300指数的走势一致。 ETF、ETF联接，LOF，QDII…… 先讲讲ETF和LOF。 这里须先补充下两个知识： 1.场外交易和场内交易 这是金融领域的常用词，所谓“场”指的就是二级市场，也就是证券交易所。 所谓场内交易，就是指在证券交易所里可以交易的，粗暴点理解，就是可以通过在证券公司开的证券账户里进行交易的。而场外交易，就是不能在证券交易所里交易的，即没办法通过证券账户进行交易的。（不知道说清楚了没，先这么理解着吧） 2.开放式基金和封闭式基金 这其实也是一种基金的分类方式，是按照运作方式来分类的。 封闭式基金，即买了之后，是不能赎回的，只能够转让给其他人，即只能场内交易。 而开放式基金，买了之后是可以随时赎回的，但是不能够转让给其他人，即只能场外交易。 所以，一般基金不是封闭式就是开放式，所谓封闭式，只能够交易，不能够申赎回；所谓开放式，不能够交易，只能够申赎。 搞清楚上述两点之后，就可以回来谈谈ETF和LOF了。 首先，ETF，学名交易型开放式指数基金。 所谓交易型开放式，即它是一个开放式基金，又可以在二级市场交易。咦，刚刚才不是说，只有封闭式基金可以交易么？没错！这就是ETF鸡的牛逼之处，号称基金中的战斗机。至于它为什么这么牛逼，说来话长，也不是此处重点，且略过。 另外，它的名字里还暗含一个属性，就是指数基金。指数基金上一篇咱们已经讲过，指的是投资标的为某个指数所包含的一揽子股票的基金（可以翻看上一篇回顾下哈） 那么ETF基金和普通的指数基金又有什么区别呢？为什么要创造出这么个奇葩的指数基金呢？ （1）可以场内交易。可以在场内交易的ETF对比传统指数，就灵活许多，比如可以随时买进卖出，不需要跟传统基金一样需要第二天确认。 （2）交易费用较低。相比起传统的指数基金，ETF的费用较低。 （3）各种高级玩法。比如所谓的ETF套利，这其实才是ETF的牛逼所在，当由于过于复杂，且操作难度不小，继续跳过（其实最主要是我也没玩过，哈哈哈～）。 总之呢，ETF是一个牛逼的，可以在场内交易的开放式基金，并且还是一个指数型基金。 第二个，LOF，学名交易型开放式基金。 ……什么鬼，怎么又是这个，这跟上面的ETF有区别么？ 当然有啦，仔细看，不是少了个“指数”么。少了“指数”两个字，差别可不小。因为指数基金只能跟踪指数，而LOF的话，投资标的可以有很多选择。另外呢，ETF的申赎有较高的门槛，动不动就30万、50万的，而LOF相对而言就要低很多拉。其他的区别还包括了报价时间、申赎是否需要股票等等，私以为这些比较复杂，暂时没必要了解拉。 总之，LOF也是一个可交易型的开放式基金，并且比ETF更灵活点。 接下来，咱们来了解ETF和ETF联接。 上面提到了，ETF是交易型开放式指数基金，其实它还有一个名字，叫交易所交易基金，跟前面的名称相比，少了“开放式”三个字，为啥呢？因为ETF虽然可以在场外进行申赎，但是——真的很麻烦，起点高不说，它还规定必须用股票来进行申赎。什么意思呢？这个不用管，反正你就记得它基本上只能够场内交易，场外交易很麻烦就是。看下天天基金的列表，都是只支持场内交易的。 那么，这样就导致了很多想买ETF，但是又没有或不想开证券账户的人，买不了咋整啊？ 于是，这就有了ETF联接基金。它就是基金公司专门为了让那些没有证券账户，无法在证券公司进行该ETF交易的投资者也能对该ETF进行投资，而复制了一个场外可以申赎的指数基金。 至于二者的其他区别，这里也不多讲，感兴趣地可以自行查阅。 最后是QDII基金，这个比较容易理解。 度娘说，所谓QDII基金，是指在一国境内设立，经该国有关部门批准从事境外证券市场的股票、债券等有价证券业务的证券投资基金。它是在货币没有实现完全可自由兑换、资本项目尚未开放的情况下，有限度地允许境内投资者投资境外证券市场的一项过渡性的制度安排。 讲人话，就是可以投资国外证券的基金，比如下图的嘉实恒生中国企业，投资的标的就是香港上市的中国企业股票。 好了，终于把这几个奇奇怪怪的基金讲完了（让我长舒一口气），这里再放个大神的回答，个人觉得有助于加深对本篇的理解，感兴趣可以当作延展阅读咯。 分别区分一下ETF，开放式基金，封闭式基金，LOF基金, 分级基金都是些啥，有何异同点？听起来很专业的&amp;amp;amp;amp;quot;ETF&amp;amp;amp;amp;quot;到底是个啥？ 其他常见基金分级基金 （从投资标的分类来看，分级基金大多为指数基金） 首先是分级基金，最近一两年常能在新闻和财经资讯中看到各种分级基金的风险提示，或下折导致巨额亏损等。 那分级基金究竟是什么捏？ 定义：分级基金又叫“结构型基金”，是指在一个投资组合下，通过对基金收益或净资产的分解，形成两级（或多级）风险收益表现有一定差异化基金份额的基金品种。它的主要特点是将基金产品分为两类份额，并分别给予不同的收益分配。 通俗的解释就是，所谓分级基金，就是把一个母基金劈成两半，一半是优先级，也称A类份额，另一半是落后级，不对，是进取级，也称B类份额。A份额和B份额的资产作为一个整体投资，其中持有B份额的人每年向A份额的持有人支付约定利息，至于支付利息后的总投资亏损由B份额持有人承担。 还不够通俗？那我们再俗一点。 你可以这么理解，A是一个土豪，B是一个赌徒。A有钱B有胆。A稳妥为先，想获得固定收益，B赌徒心态，总想在市场上捞一把。于是A和B达成合作协议，俩人按1:1的比例共同出钱。A呢，每年拿约定的利息把钱借给B去赌（投资股票等权益类资产），B呢不管赌赢赌输，总是得按约定支付A利息。这样一来，A可以获得固定收益，B可以利用自己和从A借来的钱做更加激进的投资。 好了，关于分级基金的，目前理解这么多也就够了，你就记住，分级A就是拿固定收益，分级B就是拿A的钱（加杠杆）去投资，博取更大收益，当然承受的风险也更大。 之所以只讲这么多呢，是因为这个专栏主要以基础为主，分级基金实在无法用很简短的话说完（好一个功力不够的冠冕堂皇的借口！哈哈哈）。其实一来分级基金的风险较高，不建议初学者接触，二来由于风险太高，现在的分级B的投资门槛已经提升为30万，如此一来我等屌丝其实也没啥机会折腾了。 当然，实在对分级基金感兴趣的，推荐下大神Alex的回答，比我好得多哈。传送门：分级基金是怎么一回事？ - 知乎 之后有时间再考虑专门写一个分级基金的专题。 保本基金 （从投资标的分类来看，保本基金大多为混合基金） 接下来是保本基金，相比分级基金而言，保本基金就容易理解得多得多…… 保本基金就是在一定期间内，对所投资的本金提供一定比例的保证保本基金，基金利用利息或是极小比例的资产从事高风险投资，而将大部份的资产从事固定收益投资，使得基金投资的市场不论如何下跌时，绝对不会低于其所担保的价格，而达到所谓的「保本」作用。 很好理解把，之所以能保本，就是该基金将大部分投资于固定收益资产，所以能保本。（啥？不清楚为什么投资固定收益的资产就能保本？银行存款就是固定收益，你存银行难道不能保本？） 对于保本基金，有两个问题需要特别注意： 1.保本基金一般都有一个固定的期限，在期限内如果你赎回了，是不承诺保本的哦。 2.保本周期内进行申购，也是不承诺保本的哦。 啥意思呢？就是保本基金只有在新成立的时候（或者进入第二个保本期的过度期的时候）购买，才能承诺保本。 这是为什么呢？你想想，保本基金新成立的时候净值是1元，它给你的保本承诺是你3年后至少还是1元。但是呢，如果在保本期限内，比如过了3个月后，该基金净值涨到了1.5元（当然现实是不可能涨这么多），这时候你购买的话，你的本金是1.5元，难道它在结束的时候给你承诺给你1.5元？那它不压力大死了。 详细还可以参考基金甲的回答啊，写得挺好的，传送门：普通投资者购买保本型基金有何利弊？ - 知乎 量化基金 （从投资标的分类来看，量化基金为大多为混合基金和股票基金） 最后是量化基金。 什么是量化基金呢？也就是采用量化投资的方法去管理的基金。 什么是量化投资呢？就是“通过借助统计学、数学方法，运用计算机从海量历史数据中寻找能够带来超额收益的多种“大概率”策略，并纪律严明地按照这些策略所构建的数量化模型来指导投资，力求取得稳定的、可持续的、高于平均的超额回报，其本质是定性投资的数量化实践。” 简单点讲，就有点像数据分析和概率论。比如说，我通过数据分析，发现只要从“0开始学基金投资”专栏的关注人数一增加，股市就有80%的概率会上涨。OK，那我就利用这个规律，不以我的意志为转移（不管我今天开心或不开心），只要看到专栏人数一增加，我立马买入股票，这样一来，我就有80%的赚钱概率。 哇！既然这么简单，那采用量化投资的量化基金一定很牛逼把，稳赚啊老铁！ 2 young 2 simple！现实的投资世界是很复杂滴，就别说规律不好找，找到了是否能够完全没有干扰地执行都是个巨大的问题啦。 基金怎么买基金的买卖1.申购和认购 第一次买基金的时候，我们最常遇到的问题就是，“申购”是什么？“认购”又是什么？当然现在很多网站（包括基金公司和三方平台），为了避免让投资者疑惑，不管申购和认购，一律称为购买。但是呢，在查看费率的时候，我们还是会看的基金写的是申购费率，有时写的又是认购费率。那这两者究竟有什么不同呢？ 其实很简单，对于新成立的基金，购买行为称做认购；对于成立后的基金，购买行为称为申购。除此之外呢，还有一个比较重要的区别，就是确认时间。 目前而言，认购的确认时间，是以新基金的募集时间为准；而申购的确认时间，一般为T+1日。 认购时间： 我们在第一部分的时候，讲过一只基金的一生。忘了可以回顾下（贴链接） 认购其实对应的就是上述流程的“募集资金”阶段，这个时期长短是由基金公司决定的，不论是什么时候认购的，都必须等到募集结束之后，才能够确认的。 申购时间： 基金的申购并非是实时交易的，一般是先交钱，之后再交货。为什么呢？因为每天买鸡卖鸡的人实在太多了，基金公司根本顾不过来。于是，只好让买鸡的人先交钱，然后晚上统一算清楚谁买了鸡，买了多少钱，第二天再把鸡给到你。 但是这样的话还有个问题。就是如果晚上边算账的时候还不停有人来买卖呢，那不就没完没了？所以，为了避免这种情况，基金公司又设置了一个时间节点，即15:00（与股市收盘时间一致）。凡事15:00之后才买的鸡，那就要等到次日晚上才帮你算账，你就要等到第三天才能收到鸡啦。因此，就以15:00-次日15:00作为一个交易日，也就是我们常说的T日。 目前而言，申购基金的普遍确认时间是T+1日，当然也有一些特殊的基金是需要T+2或3的。 有人问，花了这么长的篇幅讲这个确认时间作甚？ 因为啊，常常人有 “诶，我刚刚申购了基金并且付了款，但是账户却查询不到，是不是被骗了？” “诶，我昨晚明明申购了基金，说的第二天确认，为什么现在查不到，是不是别骗了？” “诶，我明明周四晚上申购了基金，说好的第二天确认，结果到了周日还查不到，是不是被骗了？”（其实是，周四晚上申购，是算在周五的交易日操作的，而周六、周日不是工作日，所以要到周一才能确认。） 2.赎回、极速赎回（快赎） 相比购买，卖出则简单的多。不论申购、认购，卖出统统成为称为赎回。 需要注意的是确认时间，上面讲过申购的确认时间一般是T+1确认，但是赎回一般都是T+2或者T+3，原因其实跟申购一样，之所以时间更长，大概是为了资金安全把。 这里要补充一下，现在不少基金公司的货币基金，已经可以支持赎回T+0到账，即现在赎回，基本上立即到账。 这里重点要说另一个功能——极速赎回。 极速赎回是天天基金的说法，其他基金公司或平台所说的快赎（快速赎回），都是一个意思。 那极速赎回是什么意思呢？又有什么作用呢？ 首先需要先理解一个概念，叫做基金转换。 基金转换是指投资者在持有本公司发行的任一开放式基金后，可将其持有的基金份额直接转换成本公司管理的其它开放式基金的基金份额，而不需要先赎回已持有的基金单位，再申购目标基金的一种业务模式。 这个很好理解把，比如你持有华夏基金的基金A，现在你想买华夏基金的另一只基金B。通常做法是赎回A，再申购B，但其实你可以直接进行基金转换，把A直接换成B。 那这样做的意义在哪里呢？结合货币基金的T+0，它的优势就显示出来了。 前面我们提到，赎回一般需要T+2或者T+3，但是呢如果在赎回的时候，现将基金转换成货币基金，因为基金转换到货币基金通常T+1日即可完成，这样一来，叠加上货币T+0的功能，即可以做到T+1赎回啦。 3.使用活期宝支付 最后来讲讲另一个重要功能，叫做使用活期宝（即货币基金）支付。 这个名字同样来自天天基金，其他基金包括汇添富基金公司的现金宝购买，招商基金的招钱宝购买，都是一个意思哈。 这是个什么功能呢？ 咋一看是不是跟上面提到的快速赎回有点类似，但其实是原理不同的，快赎其实就是是基金转换，而这里的使用货币基金购买，实际的操作是先赎回货币基金，同时再申购其他基金。 当然啦，原理不需要我们去细究，只要知道这么做的好处是啥就行： 1.如原来买了活期宝（货币基金），现在不需要赎回就直接就可以买其他基金，省了时间 2.一般而言，为了鼓励投资者使用这种方式购买基金，基金公司或平台都会针对这个功能进行费率打折，而且力度还满大（比如天天基金就是1折），还是满划算滴。 基金去哪里买上篇说完了基金的买与卖，今天说一说基金应该去哪里买。 要想知道去哪里买基金好，先要了解基金是怎么卖的。 一、基金的直销和代销基金的销售分为直销和代销。直销，是由基金公司直接销售。代销，是由其他机构代为销售。 好比卖空调的直营店和超市。我们在哪可买到格力的空调？一是格力电器的直营店，卖的全是格力产品。二是超市等地方，卖着各种品牌的空调，也包括格力。 基金直销那基金的直营店是哪呢？当然就是基金公司。需要记住的是，每个基金公司只能卖自家基金产品。比如招商基金只能卖招商基金管理的基金，而不能卖广发基金的产品。（你在格力直营店是买不到美帝空调滴） 那直营店怎么买呢？要跑到基金公司去？当然不用，上基金公司的官网即可，现在各家基金公司也推出了APP和微信公众号，可以直接买卖基金的。 （补充小知识，证券和银行都会有很多网点的，证券叫营业部，银行叫支行，但是基金公司是没有的哦，一般只有一个总部和分公司，但没有所谓网点给你办业务的。因为基金大部分是通过代销来销售的，直销的话则以线上方式为主，因此没有设立网点的必要） 基金代销那基金代销是指哪些呢？跟卖空调的一样，直销只有直营店，但是代销就有很多机构可以做了。比如超市可以卖空调，家电城可以卖空调，拿到经销资格的个体户，也可以卖空调。所以呢，基金代销也一样，代销机构包括银行、证券公司和第三方销售平台（比如天天基金）。 二、直销和代销，哪里买更好？ 现在我们知道了，基金可以通过直销和代销来购买，那么哪种方式购买更好呢？我们从三个方面来对比下。 1.哪里更便宜？购买基金是需要收费的。费用可以分为两种，一种是手续费（申购费、认购费、赎回费，下一篇会细讲），另一种则是管理费。管理费一般是不打折的，合同规定多少是多少。而手续费呢，根据营销需求，是可以进行打折的。所以，我们要买的更便宜，就看哪里手续费低。 一般而言，直销更便宜一点。为什么捏？我们先来讲讲逻辑。（不感兴趣的可以直接跳过哈）还是卖空调这个事。比如我们是代销一个空调，那我们的利润来源是什么？无非，要么是能够拿到更低的成本价，要么是能以更高的价格卖出去。但是，对于基金而言，代销机构一来无法享受更低的价格，二来又不能用更高的价格卖出去（证监会规定的），那代销机构的利润从何而来？答案就是基金公司的给的佣金啦。你帮我卖多少，我就按比例给你钱呗，算是犒赏你的费用。那这部分费用从哪里出呢？就是从上述的手续费用来的。所以，你从代销机构那里买基金所交的手续费，一部分就被当成了佣金给到了代销机构。 再看直销。对于直销，由于不需要将手续费跟代销机构分成，为了吸引更多的投资者，基金公司通常会通过让利手续费的方式（即给手续费打折）。这样一来通过直销购买就可以获得更低的手续费折扣了。 所以，从逻辑上讲，是直销更便宜一点。但其实现在很多代销渠道的费率也很低了。比如天天基金网，购买费率已经是一折了，基本上跟基金公司的直销费率持平。当然有时为了促销，基金公司会通过一些方法把费率打到0折，比如招商基金的0元购栏目。 2.哪里更方便？上面提到，基金公司是不能卖其他基金公司的产品的。但是代销是可以滴，所以代销的品类更齐全。 还是买空调，在格力的直营店，你只能够买格力空调，最多在格力自家的不同产品去对比。 但是在超市，你可以对比各种品牌各种型号的空调，对比和选择当然也就更多一些。 （招商基金和天天基金的对比） 另外一个是操作层面。在任何一个渠道买基金，都是需要先开户的，有的平台可能1、2分钟搞定，有的平台如果出幺蛾子，可能要花个10来分钟。如果买不同家的基金产品，每次都要跑到各家基金公司的平台做开户动作，那真的会心累死的。而在代销上，你开一次户，就可以买各家产品。 3.哪里买安全？这个所有人最关心的问题。其实，除非很小的平台（你没听过的，没什么人用的），一般不论直销和代销，都是比较安全的。因为你不论是直销还是代销，你买的都是基金公司的产品，责任都在基金公司那里。除非基金公司发生了问题，否则你所投的基金，都是安全的。然而基金公司因为收到监管机构很强的监管，一般是不会出现什么风险问题的。（这里指的安全，不是指本金安全不会亏损，是指跑路、公司倒闭之类的风险哈） 综上所述， 如果你的资金不是很多（对1.5%左右的购买费率不敏感）， 不是某家基金公司的死忠粉（不限制于只买他们家的产品）， 那么，代销其实是个比较方便的选择。 三、代销的购买渠道如何选择？ 上面我们提到在两个条件的前提下，建议大家通过代销的方式进行购买比较方便。 当然了，代销平台包括银行、券商、第三方平台（如天天基金），由于篇幅关系，对比就不展开了，直接用个表格给大家展示下。 （感谢知友的提醒，下图中的“蚂蚁聚宝”目前已改名“蚂蚁财富”，由于找不到原表格，所以就不改图片了哈） 小结一下， 1.基金销售包括直销和代销两种方式。直销指基金公司自己卖，代销指基金公司委托银行、证券公司、第三方平台帮忙卖。 2.一般而言，基金公司直销（官网、微信、APP）费率有优势，不过目前第三方平台（天天基金、蚂蚁聚宝）的费率也挺低了，基本购买费率1折左右。 3.从购买的便捷程度而言，选择代销平台会好一点，代销平台中银行和券商的费率较高，第三方平台的费率较低。 费用怎么算首先，我们了解下，投资基金中所涉及到的费用都有哪些。 从天天基金网，随便打开一个基金的费率详情。 可以看到，跟基金相关的费用主要包括两种类型，一种为运作费用，另外一种为交易费用。 一、运作费用： 1、管理费：就是帮你管理这个基金收取的佣金。 2、托管费：这是基金公司代资管托管银行收取的托管费用。 3、销售服务费：这是一个比较特殊的费用项目，通常只会出现在一些C类份额的基金上。（关于基金的A、B、C这个日后专门写一下。） 以上三项费用，都是按日计提的，即根据你持有的份额，按照持有的时间去计算，然后直接从你的基金资产中扣除。 一般而言，管理费（同托管费）的计算方式为： 每日应付管理费=前一日基金资产净值*年管理费／365 举个例子，你买了某个基金10000元，管理费是1.5%一年，那么第二天需缴纳的管理费就是，10000元*1.5%／365=0.41元。 现在的管理费和托管费，大多是按日计提，即每日计算，然后按月一次性支付。 下图为某只基金的基金合同，关于管理费用计提和支付方式。 在购买基金的时候，建议大家可以把基金合同里的基金费率和税收一项关注下。 与按日计提的运作费用不同的是，交易费用，都按次收费的。即只有在每次交易的时候，直接一次性收费。 二、交易费用 1、申购费：申购基金时的手续费。 2、认购费：认购新基金时的手续费。 3、赎回费：赎回基金时的手续费。 4、转换费：基金转换时的需要支付的费用。 需要注意的是，每个基金的申购费、认购费并不是固定的，而是根据交易的金额大小有所不同。基金公司当然希望你买越多越好，所以呢，认购、申购费率随着金额越大而越小。 赎回费呢，也同样不是固定的，而是根据持有的时间年限不同。基金公司当然希望你拿得越久越好，因为拿得越旧，你贡献的管理费越多啊，所以呢，赎回费是持有时间越长，费率越低。具体需要查看具体基金的费率政策。 申购费（认购费同）的计算 申购费用=申购金额*申购费率 净申购金额=申购金额-申购费用 申购份额=净申购金额／申购当日基金资产净值 举个例子，某个基金当天价格为1.5元／份，申购费为0.8%，你准备拿1000元来申购这个基金。 那么， 申购费用=1000*0.8%=8元 净申购金额=1000-8=992元 申购份额=992/1.5=661.333份 所以，你当天拿1000元买入该基金，实际上买到了661.333份，基金资产总额992元。 赎回费的计算 赎回费=赎回当日该基金单位资产净值赎回份额赎回费率 赎回金额=赎回当日该基金单位资产净值*赎回份额-赎回费 再举个例子。你持有某基金1000份，该基金当日价格为1.5元／份，赎回费率为0.05% 赎回费=1.510000.05%=0.75元 实际赎回金额=1.5*1000-0.75=1499.25元 转换费的计算 上一篇我们提到过，如果想从同一家基金管理公司下的A基金转到B基金，有两种方法： （1）赎回A基金，申购B基金。这里需要支付的费用=A的赎回费用，B的申购费用。 （2）直接从A基金转换为B基金。这里需要支付的费用=A的赎回费用+A、B两只基金的申购费率补差。 因此，基金转换费用=转出基金的赎回费+两个基金的申购费率补差 假设你持有A基金100份，每份刚好1元。 A基金，申购费1.5%，赎回费0.5% B基金，申购费1.5%，赎回费0.1% 那么，你从A转换到B，需要支付的转换费=10010.5%=0.5元（两个基金的申购费率相同，所以不需要补差）。这样一来，比你直接赎回A，然后再申购B，要划算不少哦。 小结问题1：基金是什么 问题2：基金的分类 问题3：基金怎么买 第一个问题，关于基金是什么，我们对比了基金和股票、债券的区别，明确了基金的本质是一种委托关系，委托专业机构即基金管理公司帮你进行投资，接着我们介绍了基金的相关主体包括基金投资人、基金管理公司、基金托管公司，然后我们又剖析了一只基金的生命周期，将经历产品设计-证监会审批-确认发行-募集资金-建仓期封闭、正式运作、清盘等环节。 第二个问题，关于基金的分类，我们先讲了按照最基础的投资标的，可以将基金分成货币型基金、债券型基金、股票型基金、混合型基金、指数型基金；然后，我们又帮大家区分了几个比较奇奇怪怪的基金，包括ETF、ETF联结、LOF和QDII彼此的联系和区别；最后，补充讲了几个比较常见的特殊基金，如分类基金、保本基金和量化基金。 第三个问题，关于基金怎么买，我们先讲了基金的购买方式有认购（新基金）和申购（已成立基金），卖出方式包括赎回和快赎（极速赎回），讲快赎的时候顺带提了基金转换的概念，还补充了使用货币基金购买其他基金的模式；接着，我们讲了基金购买渠道分为直销和代销，并从购买费用、便捷程度和安全性三个方面进行了对比，还给大家提供了一个代销渠道的对比表格；最后，我们了解基金的费用，包括了运作费和交易费，运作费又可分为管理费、托管费、销售服务费，以按日计提的方式收取，而交易费则包括了申购费、认购费、赎回费和转换费等，则是一次性收费的方式；最后，我们也举例说明了各项费用的计算方法。 如果顺着上面的串讲，你能够回忆起各部分知识，恭喜你，已经毕业啦！ 当然，有老铁会说，看了这么多还是不知道从而下手，然并卵啊～ 其实咧，这投资就跟学做菜是一样一样的。 学做菜之前，你得先了解得，什么是锅碗瓢鹏和柴迷油盐，接下来才能开始动手吧。 并且，锅碗瓢鹏、柴米油盐酱醋茶这些东西都是客观存在的，而做出来的菜，却是根据每个人的口味偏好、烹饪能力而各有不同。 所以呢，这个专栏主要的作用是介绍锅碗瓢盆使用方法等基础知识，至于要怎么投资，那根据不同的投资需求、投资理念，具体方法也有所不同。 当然，这里先介绍两道容易操作、又适应各种口味的入门菜式——番茄炒蛋，紫菜蛋花汤 什么鬼？ 好啦，其实是给大家两个比较简单的入门建议啦。 入门建议1：用货币基金代替银行活期 货币基金是什么，不用我再介绍了吧，风险有多低，也不用我再多说了吧？ 为什么要用它来代替银行存款呢？ 我们先看下最新的银行存款利率哈 然后我们随便拉下目前市场上的货币基金， 先看下7日年化，前20名的货基都已经4.7%的年化收益，当然这个节点有基金公司估计作答收益的嫌疑，那我们再看下35日年化，基本上也都达到3.5-4.5之间，而随着美联储加息和缩表的预期不停，至少今年年内，货币基金都将维护在较高的水平。 如果存款10万的话，定期存款一年的收益是1500元，活期存款（就是钱趴在银行账上，你动都不动）的话，是350元，而如果是货币基金的话，大概可以拿到3000～4000元左右，这差价，都可以买小米手机啦～ 所以请记住，你银行里躺着的每一分钱都是你的员工啊，要让他们为你创造价值，而不是让他们躺在那里偷懒啊！！ 入门建议2：选择适当的指数基金进行定投 在基金投资中，定投这个方法也被反复提及。 所谓定投，意思就是定时定量地投资某一个标的（该标的长期来看有增长预期），从而达到分散风险，获取长期收益的效果。 定投的原理、优势这里不展开，感兴趣可以参考： 基金定投怎么开始？ - 知乎 基金定投一定赚钱吗？ - 知乎 这里主要讲可以选择什么基金进行定投。 从定投的方法可以知道，是通过定量定时的投入有增长潜力的标的，以获得长期的收益。 因此，定投的重要前提就是，投资标的要有增长潜力。我们来看下各类基金： 货币基金，货币基金是一种低风险、低收益的产品，年化收益率常年徘徊在2-4%之间，所以排除； 债券基金，债券收益基本固定，因此也潜力不大； 而剩下的混合型基金（偏股型）、股票型基金、指数型基金，基本上比较符合这个标准。 而这当中呢，又最推荐指数基金。当然，作为新手而言，混合型和股票型，因为种类较多，细分主题也很多，选择起来可能还有一定难度，因此，建议选择指数型基金进行定投，理由如下： 1、混合型和股票型为主动管理型基金（即基金经理主动选择合适的品种去投资），这样一来收益会受基金经理的管理水平和风格所影响，新手比较难以判断和选择； 2、指数型基金属于被动型基金，即基金经理只需要复制指数进行投资，可以一定程度上规避主动管理的风险； 当然，指数基金也分多种，究竟应该选择什么指数基金呢？ 建议如下： 1、基金公司不重要，因为只要是复制同一个指数（如沪深300指数），那么收益相差不会太大，因此关键在于指数的选择； 2、指数选择建议选择沪深300、上证50等代表大盘的指数，而避免选择像创业板指数等代表小盘股的指数，因为一来目前A股大盘股的估值较合理，甚至偏低；而来目前的政策环境，如IPO提速，大股东减持新规等，都在一定程度上利空创业板和小市值的股票，而利好大盘股、蓝筹股。 上面这坨如果看不懂没关系，总之你就记得可以选择哪些指数，不要选择哪些指数即可。 （在考虑是不是应该开个从0开始学股票投资的专栏呢？） 至于定投的具体每月投多少，投多久，这个就大家自己根据实际情况却去尝试吧。每月投个100元也是可以的，毕竟走出了这一步，你才会真正开始去关注投资。","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"基金","slug":"基金","permalink":"http://yoursite.com/tags/%E5%9F%BA%E9%87%91/"}]},{"title":"Python","slug":"code/python","date":"2020-03-05T03:14:00.000Z","updated":"2021-05-19T11:18:03.697Z","comments":true,"path":"2020/03/05/code/python/","link":"","permalink":"http://yoursite.com/2020/03/05/code/python/","excerpt":"","text":"了解PythonPython的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码。如果一个资深程序员向你炫耀他写的晦涩难懂、动不动就几万行的代码，你可以尽情地嘲笑他。 那Python适合开发哪些类型的应用呢？ 首选是网络应用，包括网站、后台服务等等； 其次是许多日常需要的小工具，包括系统管理员需要的脚本任务等等； 另外就是把其他语言开发的程序再包装起来，方便使用。 最后说说Python的缺点。 任何编程语言都有缺点，Python也不例外。优点说过了，那Python有哪些缺点呢？ 第一个缺点就是运行速度慢，和C程序相比非常慢，因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。 须知Python程序是缩进书写代码并且大小写敏感的pass 不做任何事情，一般用做占位语句。 基础变量赋值Python 中的变量赋值不需要类型声明。 每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。 每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。例：counter = 100 # 赋值整型变量多个变量赋值Python允许你同时为多个变量赋值a = b = c = 1 标准数据类型在内存中存储的数据可以有多种类型。 例如，一个人的年龄可以用数字来存储，他的名字可以用字符来存储。 Python 定义了一些标准类型，用于存储各种类型的数据。 Python有五个标准的数据类型： Numbers（数字）String（字符串）List（列表）Tuple（元组）Dictionary（字典） Python数字Python支持四种不同的数字类型： int（有符号整型）long（长整型[也可以代表八进制和十六进制]）float（浮点型）complex（复数） int(x [,base ]) 将x转换为一个整数 long(x [,base ]) 将x转换为一个长整数 float(x ) 将x转换到一个浮点数 complex(real [,imag ]) 创建一个复数 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为Unicode字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 Python math 模块、cmath 模块 Python字符串字符串或串(String)是由数字、字母、下划线组成的一串字符。 一般记为 : s=”a1a2···an”(n&gt;=0)它是编程语言中表示文本的数据类型。 python的字串列表有2种取值顺序: 从左到右索引默认0开始的，最大范围是字符串长度少1从右到左索引默认-1开始的，最大范围是字符串开头如果你要实现从字符串中获取一段子字符串的话，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。 [头下标:尾下标] 获取的子字符串包含头下标的字符，但不包含尾下标的字符。 比如: &gt;&gt;&gt; s = &#39;abcdef&#39; &gt;&gt;&gt; s[1:5] &#39;bcde&#39; Python列表List（列表） 是 Python 中使用最频繁的数据类型。 列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。 列表用 [ ] 标识，是 python 最通用的复合数据类型。 列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。 更新列表 list.append(‘Google’) ## 使用 append() 添加元素 删除列表元素 del list1[2] Python列表脚本操作符 Python列表截取 Python列表函数&amp;方法 Python 元组元组是另一个数据类型，类似于 List（列表）。 元组用 () 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。 #!/usr/bin/python # -*- coding: UTF-8 -*- tuple = ( &#39;runoob&#39;, 786 , 2.23, &#39;john&#39;, 70.2 ) tinytuple = (123, &#39;john&#39;) print tuple # 输出完整元组 print tuple[0] # 输出元组的第一个元素 print tuple[1:3] # 输出第二个至第四个（不包含）的元素 print tuple[2:] # 输出从第三个开始至列表末尾的所有元素 print tinytuple * 2 # 输出元组两次 print tuple + tinytuple # 打印组合的元组 以上实例输出结果： (&#39;runoob&#39;, 786, 2.23, &#39;john&#39;, 70.2) runoob (786, 2.23) (2.23, &#39;john&#39;, 70.2) (123, &#39;john&#39;, 123, &#39;john&#39;) (&#39;runoob&#39;, 786, 2.23, &#39;john&#39;, 70.2, 123, &#39;john&#39;) 以下是元组无效的，因为元组是不允许更新的。而列表是允许更新的： 实例(Python 2.0+) #!/usr/bin/python # -*- coding: UTF-8 -*- tuple = ( &#39;runoob&#39;, 786 , 2.23, &#39;john&#39;, 70.2 ) list = [ &#39;runoob&#39;, 786 , 2.23, &#39;john&#39;, 70.2 ] tuple[2] = 1000 # 元组中是非法应用 list[2] = 1000 # 列表中是合法应用 Python 转义字符 Python 字符串格式化 Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。 在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。 如下实例： #!/usr/bin/python print &quot;My name is %s and weight is %d kg!&quot; % (&#39;Zara&#39;, 21) 以上实例输出结果： My name is Zara and weight is 21 kg! Python 三引号 Python 中三引号可以将复杂的字符串进行赋值。 Python 三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。 三引号的语法是一对连续的单引号或者双引号（通常都是成对的用）。 &gt;&gt;&gt; hi = &#39;&#39;&#39;hi there&#39;&#39;&#39; &gt;&gt;&gt; hi # repr() &#39;hi\\nthere&#39; &gt;&gt;&gt; print hi # str() hi there 三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。 一个典型的用例是，当你需要一块HTML或者SQL时，这时当用三引号标记，使用传统的转义字符体系将十分费神。 errHTML = &#39;&#39;&#39; &lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt; Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt; &lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt; &lt;B&gt;%s&lt;/B&gt;&lt;P&gt; &lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back ONCLICK=&quot;window.history.back()&quot;&gt;&lt;/FORM&gt; &lt;/BODY&gt;&lt;/HTML&gt; &#39;&#39;&#39; cursor.execute(&#39;&#39;&#39; CREATE TABLE users ( login VARCHAR(8), uid INTEGER, prid INTEGER) &#39;&#39;&#39;) Unicode 字符串 Python 中定义一个 Unicode 字符串和定义一个普通字符串一样简单： &gt;&gt;&gt; u&#39;Hello World !&#39; u&#39;Hello World !&#39; 引号前小写的&quot;u&quot;表示这里创建的是一个 Unicode 字符串。如果你想加入一个特殊字符，可以使用 Python 的 Unicode-Escape 编码。如下例所示： &gt;&gt;&gt; u&#39;Hello\\u0020World !&#39; u&#39;Hello World !&#39; 被替换的 \\u0020 标识表示在给定位置插入编码值为 0x0020 的 Unicode 字符（空格符）。 python的字符串内建函数 字符串方法是从python1.6到2.0慢慢加进来的——它们也被加到了Jython中。 这些方法实现了string模块的大部分方法，如下表所示列出了目前字符串内建支持的方法，所有的方法都包含了对Unicode的支持，有一些甚至是专门用于Unicode的。 Python 字典字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。 两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 字典用”{ }”标识。字典由索引(key)和它对应的值value组成。 #!/usr/bin/python # -*- coding: UTF-8 -*- dict = &#123;&#125; dict[&#39;one&#39;] = &quot;This is one&quot; dict[2] = &quot;This is two&quot; tinydict = &#123;&#39;name&#39;: &#39;john&#39;,&#39;code&#39;:6734, &#39;dept&#39;: &#39;sales&#39;&#125; print dict[&#39;one&#39;] # 输出键为&#39;one&#39; 的值 print dict[2] # 输出键为 2 的值 print tinydict # 输出完整的字典 print tinydict.keys() # 输出所有键 print tinydict.values() # 输出所有值 输出结果为： This is one This is two &#123;&#39;dept&#39;: &#39;sales&#39;, &#39;code&#39;: 6734, &#39;name&#39;: &#39;john&#39;&#125; [&#39;dept&#39;, &#39;code&#39;, &#39;name&#39;] [&#39;sales&#39;, 6734, &#39;john&#39;] 字典内置函数&amp;方法 Python数据类型转换 Python算术运算符 Python比较运算符 Python赋值运算符 Python位运算符 Python逻辑运算符 Python成员运算符 Python身份运算符 Python运算符优先级 Python 条件语句if 判断条件： 执行语句……else： 执行语句…… Python 循环语句 Python While 循环语句count = 0 while count &lt; 5: print count, &quot; is less than 5&quot; count = count + 1 else: print count, &quot; is not less than 5&quot; Python for 循环语句for num in range(10,20): # 迭代 10 到 20 之间的数字 for i in range(2,num): # 根据因子迭代 if num%i == 0: # 确定第一个因子 j=num/i # 计算第二个因子 print &#39;%d 等于 %d * %d&#39; % (num,i,j) break # 跳出当前循环 else: # 循环的 else 部分 print num, &#39;是一个质数&#39; 时间 time手册 函数 大同小异菜鸟手册 个人代码获取代理import requests from lxml import etree import time from multiprocessing import Pool import multiprocessing import sys from fake_useragent import UserAgent ua = UserAgent() class Get_Proxy_IP(object): def __init__(self, totalPage=3): self.url = &quot;https://ip.ihuan.me/today.html&quot; self.totalPage = totalPage self.get_proxy_list = [] def start(self): try: todayPage = etree.HTML(requests.get(self.url, headers=&#123; &quot;User-Agent&quot;: ua.random, &#125;).content.decode()).xpath(&quot;//div[position()&lt;=%s][@class=&#39;bs-callout bs-callout-info&#39;]/a/@href&quot; % (self.totalPage)) for item_url in todayPage: self.get_item_ip(item_url) time.sleep(3) f = open(&#39;ip_proxies_valid.txt&#39;, &#39;w+&#39;) for ip in self.get_proxy_list: f.write(ip) f.close() print(&quot;数据保存至ip_proxies_valid.txt&quot;) except: print(&quot;被屏蔽了&quot;) def get_item_ip(self, item_url): try: print(&quot;https://ip.ihuan.me&quot;+item_url) page_content = etree.HTML(requests.get(&quot;https://ip.ihuan.me&quot;+item_url, headers=&#123; &quot;User-Agent&quot;: ua.random, &#125;).content.decode()).xpath(&quot;//p[@class=&#39;text-left&#39;]/text()&quot;) for item in page_content: item_ip = item[0:item.find(&quot;@&quot;)].replace(&quot; &quot;, &quot;&quot;) if len(item_ip) &gt; 6: self.get_proxy_list.append(item_ip+&quot;\\n&quot;) except: pass if __name__ == &quot;__main__&quot;: Get_Proxy_IP(2).start() 代理请求封装import requests import random from fake_useragent import UserAgent from multiprocessing import Pool import multiprocessing ua = UserAgent() proxy_ip_arr = [] with open(&#39;ip_proxies_valid.txt&#39;, &#39;r&#39;) as f: proxy_ip_arr = f.readlines() f.close() # 防止报错连接过多 requests.urllib3.disable_warnings() requests.adapters.DEFAULT_RETRIES = 5 requests.urllib3.PoolManager(num_pools=10000) s = requests.session() s.keep_alive = False def use_proxy_requst(url=&quot;https:www.baidu.com&quot;, Referer=&quot;&quot;, proxies=&#123; &#39;http&#39;: random.choice(proxy_ip_arr).strip(&quot;\\n&quot;), &#125;): # print(&quot;代理IP：%s&quot; % (proxies[&#39;http&#39;])) # print(url,Referer,proxies) try: response = requests.get( url, headers=&#123; &#39;Connection&#39;: &#39;close&#39;, &quot;User-Agent&quot;: ua.chrome, &quot;Referer&quot;: Referer &#125;, proxies=proxies, timeout=3) # &#125;,timeout=2, verify=False) # print(proxies[&#39;http&#39;]+&quot;有效！&quot;) return response except BaseException as e: # print(e) # raise RuntimeError() pass def test_proxy_ip(): store_ip_list = [] test_file = &quot;ip_proxies_valid.txt&quot; # test_file=&quot;test_prixy_ip.txt&quot; print(&quot;开始验证!&quot;) with open(test_file, &#39;r&#39;) as f: store_ip_list = f.readlines() f.close() print(&quot;共需要测试&quot;+str(len(store_ip_list))+&quot;个ip&quot;) p = Pool(20) for ip in store_ip_list: # use_proxy_requst(&quot;https://www.baidu.com/&quot;, &quot;&quot;, &#123;&#39;http&#39;: ip.strip(&quot;\\n&quot;)&#125;) p.apply_async(use_proxy_requst, (&quot;https://www.baidu.com/&quot;, &quot;&quot;, &#123;&#39;http&#39;: ip.strip(&quot;\\n&quot;)&#125;,)) p.close() p.join() if __name__ == &quot;__main__&quot;: # response = use_proxy_requst(&quot;https://7v57.com/&quot;) # print(response) # if response.status_code == 200: # print(&quot;有效&quot;) # else: # print(&quot;无效&quot;) test_proxy_ip() 删除目录下空文件夹import os def remove_null_fille(basePath=&quot;./&quot;): fileList = os.listdir(basePath) fileNum = len(fileList) for i in fileList: try: os.rmdir(basePath+&quot;/&quot;+i) print(basePath+&quot;/&quot;+i+&quot;为空文件夹&quot;) except Exception as e: print(&#39;Exception&#39;, e) now_file_num = len(os.listdir(basePath)) print(&quot;完成！已删除%s个空文件夹&quot; % (fileNum-now_file_num)) 稳定爬取图片from lxml import etree import os import time from fake_useragent import UserAgent from string import Template from multiprocessing import Pool import random import urllib3 from proxy_requst import use_proxy_requst from tqdm import tqdm class Spider(object): def start_request(self): # *1. 获取整体网页的数据 requests try: for i in range(0, 500): print(&quot;==========正在抓取%s页==========&quot; % i) pageUrl = &quot;https://www.mzitu.com/xinggan/page/&quot; + str(i) + &quot;/&quot; response = use_proxy_requst( pageUrl, &quot;https://www.mzitu.com/xinggan/&quot;) html = etree.HTML(response.content.decode()) time.sleep(3) self.xpath_data(html, pageUrl) except: print(&quot;IP已被屏蔽 等待20s&quot;) time.sleep(20) print(&quot;再次尝试访问&quot;) self.start_request() def xpath_data(self, html, pageUrl): # *2. 抽取想要的数据 标题 图片 xpath alt_list = html.xpath(&#39;//ul[@id=&quot;pins&quot;]/li/a/img/@alt&#39;) hrefs_list = html.xpath(&#39;//ul[@id=&quot;pins&quot;]/li/a/@href&#39;) # p = Pool(2) for href, alt in zip(hrefs_list, alt_list): if not os.path.exists(&quot;img/&quot;+alt): os.makedirs(&quot;img/&quot;+alt) item_responset = use_proxy_requst(href, pageUrl) time.sleep(3) item_totalpage = int(etree.HTML(item_responset.content.decode()).xpath( &quot;//div[@class=&#39;pagenavi&#39;]/a[last()-1]/span/text()&quot;)[0]) if not os.path.exists(&quot;img/&quot;+alt) or len(os.listdir(&quot;./img/&quot;+alt))!=item_totalpage: print(alt+&quot;正在下载...&quot;) for i in tqdm(range(1, item_totalpage+1)): if not os.path.exists(&quot;img/&quot;+alt+&quot;/&quot;+alt+str(i)+&quot;.jpg&quot;): self.down_img(alt, href+&quot;/&quot;+str(i), alt+str(i), pageUrl) # p.apply_async(self.down_img, (alt, href+&quot;/&quot;+str(i), alt+str(i), pageUrl)) else: print(alt+&quot;已存在&quot;) # p.close() # p.join() print(&quot;爬取图片结束&quot;) def down_img(self, alt, href, item_name, pageUrl): # *下载图片 try: time.sleep(5*random.random()) item_responset = use_proxy_requst(href, pageUrl) item_src = etree.HTML(item_responset.content.decode()).xpath( &quot;//div[@class=&#39;main-image&#39;]/p/a/img/@src&quot;) if len(item_src) &gt; 0: response = use_proxy_requst(item_src[0], pageUrl) # 3. 存储数据 jpg with open with open(&quot;./img/&quot;+alt+&quot;/&quot;+item_name+&quot;.jpg&quot;, &quot;wb&quot;) as f: f.write(response.content) except: item_src = etree.HTML(item_responset.content.decode()).xpath(&quot;//img/@src&quot;)[0] print(item_src) print(&quot;==========文件名有误！==========&quot;) if __name__ == &quot;__main__&quot;: spider = Spider() spider.start_request() 四种方式爬取视频# coding=utf-8 from lxml import etree import os,random import sys import you_get from fake_useragent import UserAgent import re from multiprocessing import Pool import time from proxy_requst import use_proxy_requst class Spider(object): def __init__(self): self.href = &quot;https://7v57.com/&quot; def get_channel(self): # * 获取类目 response = etree.HTML(use_proxy_requst(self.href).content.decode( )).xpath(&quot;//ul[@class=&#39;tags-list&#39;]/li/*&quot;) for channel_item in response: if channel_item.text: self.start_request( channel_item.attrib[&quot;href&quot;], &quot;video/&quot;+channel_item.text+&quot;/&quot;) def start_request(self, href, path): # *获取列表分页 totalpage = int(etree.HTML(use_proxy_requst(self.href+href, self.href).content.decode()).xpath( &quot;//ul[@class=&#39;pagination&#39;]/li[last()-2]/a/text()&quot;)[0]) if type(isTotalpage) == bool else isTotalpage if not os.path.exists(path): os.makedirs(path) for i in range(1, int(totalpage)): if i == 1: item_response = use_proxy_requst(self.href+href, self.href) else: item_response = use_proxy_requst( self.href+href+&quot;/index_&quot;+str(i)+&quot;.html&quot;, self.href+href+&quot;/index_&quot;+str(i-1)+&quot;.html&quot;) self.list_data(item_response, path) def list_data(self, html, path): # *内容详情页操作 page_list = etree.HTML(html.content.decode()).xpath( &quot;//ul[@class=&#39;masonry&#39;]/li/@data-href&quot;) path = path.replace(&quot; &quot;, &quot;&quot;) # pool = Pool(moreThread) for href in page_list: if len(href) &gt; 2: item_response = use_proxy_requst(self.href+href, self.href) video_src = etree.HTML(item_response.content.decode()).xpath( &quot;//a[@class=&#39;meihua_btn&#39;]/@href&quot;)[0] video_name = etree.HTML(item_response.content.decode()).xpath( &quot;//h1[@class=&#39;article-title&#39;]/a/text()&quot;)[0].replace(&quot; &quot;, &quot;&quot;) if not os.path.exists(path+video_name+&quot;.mp4&quot;): # todo 直接下载可用 self.wait_time(video_name) self.down_video(video_src, self.href +href, path, video_name) # pool.apply_async(self.down_video, (video_src, self.href + href, path, video_name)) # pool.close() # pool.join() def down_video(self, video_src, url, path, video_name): # *常规存储方式 try: response = use_proxy_requst(video_src) if response.status_code == 200: print(video_name+&quot;完成&quot;) try: with open(path+video_name+&quot;.mp4&quot;, &quot;wb&quot;) as f: f.write(response.content) f.flush() except: print(&quot;==========保存出错！==========&quot;) else: raise RuntimeError() except: print(video_name+&quot;正常下载失败&quot;) self.blob_download(url, path, video_name) def blob_download(self, url, path, video_name): # * m3u8下载 太慢 def is_ts(val): return &quot;ts&quot; in val def ts_download(ts_item): try: if not os.path.exists(path+video_name+&quot;/&quot;+ts_item): res_video = use_proxy_requst(base_url+&quot;720kb/hls/&quot;+ts_item) if res_video.status_code == 200: if not os.path.exists(path+video_name): os.makedirs(path+video_name) with open(path+video_name+&quot;/&quot;+ts_item, &quot;wb&quot;) as f: f.write(res_video.content) except: print(&quot;download ts fail&quot;) try: response = use_proxy_requst(url).content.decode() rIndex = response.find(&quot;m3u8&quot;) lIndex = response.find(&quot;vHLSurl&quot;) findStr = response[lIndex:rIndex+5] target_url = self.txt_wrap_by(&#39;&quot;&#39;, &#39;&quot;&#39;, findStr) # ts_urls only two type so we don&#39;t get # res_blob = requests.get(target_url, headers=self.headers, # timeout=10).content.decode().splitlines() # * get m3u8 file url base_url = target_url[0:len(target_url)-10] # * 判断是否存在ffmpeg b = 1 self.wait_time(video_name+&quot;m3u8&quot;) if not isHasffmpeg: # download ts file and conact all file res_ts = use_proxy_requst(base_url+&quot;720kb/hls/index.m3u8&quot;).content.decode().splitlines() res_ts = list(filter(is_ts, res_ts)) # 创建进程池，执行10个任务 # Thread = Pool(moreThread) for i in res_ts: ts_download(i) # Thread.apply_async(ts_download, (i)) # 执行任务 # Thread.close() # Thread.join() # 调用合并 print(&quot;调用合并&quot;) try: b = os.system(&quot;copy /b %s/*.ts %s.mp4&quot;, (path+video_name, path+video_name)) except: print(&quot;调用合并失败&quot;) else: os.system(&quot;rmdir /s/q %s&quot;, (path+video_name)) else: b = os.system(&quot;ffmpeg -i %s -acodec copy -vcodec copy -absf aac_adtstoasc %s.mp4 -loglevel quiet&quot; % (base_url+&quot;720kb/hls/index.m3u8&quot;, path+video_name)) if b == 0: print(video_name+&#39;下载完成&#39;) else: raise RuntimeError() except: print(video_name+&quot;m3u8下载失败&quot;) if isHasyou_get: # todo you_get下载方式 self.you_get_download(url, path, video_name) def you_get_download(self, url, path, video_name): # *you-get下载方式 太慢 try: self.wait_time(video_name+&quot;you_get&quot;) sys.argv = [&#39;you-get&#39;, &#39;-o&#39;, path, &#39;-O&#39;, video_name+&quot;.mp4&quot;, url] you_get.main() except: print(video_name+&quot;you-get 下载失败&quot;) def txt_wrap_by(self, start_str, end, html): start = html.find(start_str) if start &gt;= 0: start += len(start_str) end = html.find(end, start) if end &gt;= 0: return html[start:end].strip() def wait_time(self, name=&quot;&quot;, timer=3): print(name+&quot;准备下载&quot;) time.sleep(5*random.random()) # for i in range(timer): # print(&quot;%s下载倒计时%s秒&quot;%(name,timer-i)) # time.sleep(1) print(name+&quot;下载中......&quot;) def wait_loading(self): while True: print(&#39;\\r下载中&#39;, end=&#39;&#39;) for i in range(1, 7): print(&#39;.&#39;, end=&#39;&#39;, flush=True) time.sleep(0.3) if __name__ == &quot;__main__&quot;: moreThread = 10 # ! 线程数 isHasffmpeg = True # ! 是否安装ffmpeg isHasyou_get = True # ! 是否安装you-get isTotalpage = 3 # ! 是下载分类全部还是仅下载前几页 int/bool spider = Spider() spider.get_channel()","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"TypeScript","slug":"code/typescript","date":"2020-02-14T03:13:00.000Z","updated":"2021-05-19T11:18:03.698Z","comments":true,"path":"2020/02/14/code/typescript/","link":"","permalink":"http://yoursite.com/2020/02/14/code/typescript/","excerpt":"","text":"了解TypeScript增强版的JavaScript，目的是为了让前端更加规范合理，TypeScript最大的目的是让程序员更具创造性，提高生产力，它将极大增强JavaScript编写应用的开发和调试环节，让JavaScript能够方便用于编写大型应用和进行多人协作。 TypeScript 与JavaScript两者的特性对比，主要表现为以下几点：TypeScript是一个应用程序级的JavaScript开发语言。（这也表示TypeScript比较牛逼，可以开发大型应用，或者说更适合开发大型应用）TypeScript是JavaScript的超集，可以编译成纯JavaScript。这个和我们CSS离的Less或者Sass是很像的，我们用更好的代码编写方式来进行编写，最后还是有好生成原生的JavaScript语言。TypeScript跨浏览器、跨操作系统、跨主机、且开源。由于最后他编译成了JavaScript所以只要能运行JS的地方，都可以运行我们写的程序，设置在node.js里。TypeScript始于JavaScript，终于JavaScript。遵循JavaScript的语法和语义，所以对于我们前端从业者来说，学习前来得心应手，并没有太大的难度。TypeScript可以重用JavaScript代码，调用流行的JavaScript库。TypeScript提供了类、模块和接口，更易于构建组件和维护。 环境安装npm install typescript -g 全局安装tsc --init生成tsconfig.json配置文件tsc -b .\\tsconfig.json 编译ts文件为js文件 声明变量ts声明变量必须制定变量类型TypeScript中的数据类型有： Undefined : 未定义（大多数不赋值的话直接编辑器就报错了）Number:数值类型;string : 字符串类型;Boolean: 布尔类型；enum：枚举类型；any : 任意类型，一个牛X的类型；void：空类型；void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是void。声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和nullArray : 数组类型;Tuple : 元祖类型；Null ：空类型。 var stature:number = 178.5 console.log(stature) var jspang:string = &quot;技术胖 jspang.com&quot; console.log(jspang) var c:boolean = false # 枚举类型enum enum REN&#123; nan , nv ,yao&#125; console.log(REN.yao) //返回了2，这是索引index，跟数组很想。 # 如果我们想给这些枚举赋值，可以直接使用=,来进行赋值。 enum REN&#123; nan = &#39;男&#39;, nv = &#39;女&#39;, yao= &#39;妖&#39; &#125; console.log(REN.yao) //返回了妖 这个字 #任意类型其实就是前端现在的方式，可以对变量赋值任意类型。 var t:any =10 t = &quot;jspang&quot; t = true console.log(t) 类型断言有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。 通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。 类型断言有两种形式。 其一是“尖括号”语法： let someValue: any = &quot;this is a string&quot;; let strLength: number = (&lt;string&gt;someValue).length; 另一个为as语法： let someValue: any = &quot;this is a string&quot;; let strLength: number = (someValue as string).length; 两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有as语法断言是被允许的。 函数声明（定义）函数必须加 function 关键字；函数名与变量名一样，命名规则按照标识符规则；函数参数可有可无，多个参数之间用逗号隔开；每个参数参数由名字与类型组成，之间用分号隔开；函数的返回值可有可无，没有时，返回类型为 void；大括号中是函数体。小括号后面的类型是函数返回值return的类型 function searchXiaoJieJie(age:number):string&#123; return &#39;找到了&#39;+age+&#39;岁的小姐姐&#39; &#125; var age:number = 18 var result:string = searchXiaoJieJie(age) console.log(result) 传参多种方式正常传参age:number,可选传参stature?:string,默认传参style:string=&#39;大胸&#39;,剩余其他参数传参...other:string[]。 function searchXiaoJieJie2(age:number,stature?:string,style:string=&#39;大胸&#39;,...other:string[]):string&#123; let yy:string = &#39;&#39; yy = &#39;找到了&#39;+age+&#39;岁&#39; if(stature !=undefined)&#123; yy = yy + stature &#125; return yy+&#39;的小姐姐&#39; &#125; var result:string = searchXiaoJieJie2(22,&#39;大长腿&#39;) console.log(result) 函数定义多种方式函数声明法函数声明法创建函数是最常用的函数定义法。使用function关键字和函数名去定义一个函数。 function add(n1:number,n2:number):number&#123; return n1+n2 &#125; 函数表达式法函数表达式法是将一个函数赋值给一个变量，这个变量名就是函数名。通过变量名就可以调用函数了。这种方式定义的函数，必须在定义之后，调用函数。下面例子中等号右边的函数没有函数名，称为匿名函数。 var add = function(n1:number,n2:number):number&#123; return n1+n2 &#125; console.log(add(1,4)) 箭头函数箭头函数是 ES6 中新增的函数定义的新方式，我们的 TypeScript 语言是完全支持 ES6 语法的。箭头函数定义的函数一般都用于回调函数中。 var add = (n1:number,n2:number):number=&gt;&#123; return n1+n2 &#125; console.log(add(1,4)) 引用类型数组初始化数组的两种方法 声明数组的方法let arr1:number[ ] //声明一个数值类型的数组 let arr2:Array&lt;string&gt; //声明一个字符串类型的数组 给数组赋值数组是存储大量数据的集合，声明数组之后，需要给数组存储数据。这时候有两种方法： 字面量赋值法：直接使用“[ ]”对数组进行赋值。构造函数赋值法： ** 字面量赋值法**//定义一个空数组，数组容量为0 let arr1:number[] = [] //定义一个数组时，直接给数组赋值 let arr2:number[] = [1,2,3,4,5] //定义数组 的同事给数组赋值 let arr3:Array&lt;string&gt; = [&#39;jspang&#39;,&#39;技术胖&#39;,&#39;金三胖&#39;] let arr4:Array&lt;boolean&gt; = [ true,false,false] 需要注意的是，在TypeScript中指定数据类型的数组只能存储同一类型的数组元素。 //报错！ 必须存储number类型的数据 let arr5:number[] = [1,2,true] 构造函数赋值法在 TypeScript 中使用 Array 这个引用类型来表示数组的，那么每一个数组都是 Array 类型的实例。那么，我们在创建数组的时候也可以使用构造函数来进行赋值。 let arr1:number[] = new Array() let ara2:number[] = new Array(1,2,3,4,5) let arr3:Array&lt;string&gt; = new Array(&#39;jspang&#39;,&#39;技术胖&#39;,&#39;金三胖&#39;) let arr4:Array&lt;boolean&gt; = new Array(true,false,false) 这两种方法，都可以给数组进行赋值，在实际开发中使用哪种方法都是可以的。 认识元祖，一种特殊的数组元祖是一种特殊的数组，元祖类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。比如，你可以定义一对值分别为string和number类型的元祖。元祖在实际开发中使用的非常少，大家了解一下就可以了，不做过多介绍。 //声明一个元祖类型let x : [string,number]//正确的初始化x = [‘hello’,10]//错误的初始化方法x = [10,’hello’] 引用类型-字符串在TypeScript中存在两种类型的字符串：基本类型字符串和引用类型字符串。 字符串的两种类型基本类型字符串：由单引号或者双引号括起来的一串字符串。引用类型字符串：用new 实例化的 String类型。JavaScript的开发人员为了大家更容易的操作字符串，有了引用类型的字符串就可以给字符串增加一系列方法了。 let jspang:string = &#39;技术胖&#39; let jspanga:String = new String(&quot;jspang.com&quot;) console.log(jspang) console.log(jspanga) 编译以后我们使用node 运行这段代码，你可以看到控制台输出了的结果，这可能跟你心里想的不太一样。 技术胖 [String: &#39;jspang.com&#39;] 需要说明的是这两种声明字符串的方法没有什么不同。基本类型的字符串可以直接使用引用类型的属性和方法。 字符串的方法字符串的截取长度等方法与js一样。 引用类型-日期对象TypeScript中使用Date这个引用类型来存储日期对象，如果你要声明一个日期变量时，记得也要注明它的类型是Date。 创建日期对象日期对象是Date的实例，可以使用构造函数的方法进行创建。并且构造函数中可以传递多种类型的参数。 1.不传递任何参数构造函数中不传递参数时，Date（）构造函数将根据当前日期和时间创建一个Date对象。我们看下面的例子理解一下。 let d:Date = new Date() console.log(d) 这时候运行node的结果如下： 2018-09-06T06:48:12.504Z 2.传递一个整数传递一个整数，这个整数代表的是距离1970-01-01 00:00:00的毫秒数（具体为什么是这个时间，小伙伴可以自己百度一下）。例如：传入参数为1000，将创建一个表示1970-01-01 00:00:01的日期对象。 我们举个例子，传递一个整数，看一下结果。 let d:Date = new Date(1000) let da:Date = new Date(2000) console.log(d) //1970-01-01T00:00:01.000Z console.log(da) //1970-01-01T00:00:02.000Z 3.传递一个字符串如果传递一个表示日期的字符串，就会生成相对应的日期对象。字符串的格式常用:yyyy/MM/dd hh:mm:ss，yyyy-MM-dd hh:mm:ss，yyyy-MM-ddThh:mm:ss等,具体可以参看下面的例子。 let d1:Date = new Date(&#39;2018/09/06 05:30:00&#39;) let d2:Date = new Date(&#39;2018-09-06 05:30:00&#39;) let d3:Date = new Date(&#39;2018-09-06T05:30:00&#39;) console.log(d1) console.log(d2) console.log(d3) 当然，他们打印出来的结果时完全相同的，所以在开发中你不用太过于纠结使用哪种方式进行声明。 4.传递表示年月日时分秒的变量let d:Date = new Date(year,month,day,hours,minutes,seconds,ms);year 表示年份，4位数字。month表示月份，数值是0(1月)11(12月)之间的整数。day 表示日期。数值是131之间的整数。hours 表示小时，数值是0-23之间的整数。minutes 表示分钟数，数值是059之间的整数。seconds 表示秒数，数值是059之间的整数。ms 表示毫秒数，数值是0~999之间的整数。至于Date类型的方法，跟JavaScript完全一样。 引用类型-正则表达式认识正则表达式创建正则表达式和字符串犹如一对好基友（类似），创建正则表达式也提供了两种方法，一种是才采用new 关键字，另一种是采用字面量的方式。 构造函数法构造函数中可以传一个参数，也可以传递两个参数。一个是字符串描述，另一个是修饰符，比如g是全局修饰符，i是忽略大小写，m是多行模式。 举个例子： let reg1:RegExp = new RegExp(&quot;jspang&quot;) //表示字符串规则里含有jspang console.log(reg1) let reg2:RegExp = new RegExp(&quot;jspang&quot;,&#39;gi&#39;) console.log(reg2) 其实现在打印出来的就是字面量的赋值方法。我们可以在视频中看到输出的结果。 字面量法其实构造函数的方法我个人用的是比较少的，我都会使用字面量法来声明正则表达式。 let reg3:RegExp = /jspang/ let reg4:RegExp = /jspang/gi RegExp中的常用方法RegExp对象包含两个方法：test( )和exec( ),功能基本相似，用于测试字符串匹配。 test(string) ：在字符串中查找是否存在指定的正则表达式并返回布尔值，如果存在则返回 true，不存在则返回 false。exec(string) : 用于在字符串中查找指定正则表达式，如果 exec() 方法执行成功，则返回包含该查找字符串的相关信息数组。如果执行失败，则返回 null。来看一个test的例子： let reg1:RegExp = /jspang/i let website:string = &#39;jspang.com&#39; let result:boolean = reg1.test(website) console.log(result) //true 这时候控制台打印出来的是true，那么我们再来看一下exec的使用方法。 let reg1:RegExp = /jspang/i let website:string = &#39;jspang.com&#39; console.log(reg1.exec(website)) //[ &#39;jspang&#39;, index: 0, input: &#39;jspang.com&#39; ] 输出的结果变为了[ &#39;jspang&#39;, index: 0, input: &#39;jspang.com&#39; ]。 面向对象编程-类的声明和使用声明类class Jspang&#123; name:string age : number skill: string constructor(name:string,age:number,skill:string)&#123; this.name = name this.age = age this.skill = skill &#125; interest()&#123; console.log(&#39;找小姐姐&#39;) &#125; &#125; let jspangObj:Jspang = new Jspang(&#39;技术胖&#39;,18,&#39;web&#39;) jspangObj.interest() 我们先用class关键字声明了一个类，并在里边声明了name和age属性。constructor为构造函数。构造函数的主要作用是给类中封装的属性进行赋值。 类的继承继承：允许我们创建一个类（子类），从已有的类（父类）上继承所有的属性和方法，子类可以新建父类中没有的属性和方法。 现在技术胖要繁衍生息了，跟准备生个儿子（也就是我们说的子类）。那我的儿子一定要比我强啊，他不仅完全继承了我的基因，还增加了帅气的属性和赚钱的本领。 我们看看如何用程序实现。 class JsShuai extends Jspang&#123; public xingxiang:string = &#39;帅气&#39; public zhuangQian()&#123; console.log(&#39;一天赚了一个亿&#39;) &#125; &#125; let shuai = new JsShuai(&quot;技术帅&quot;,5,&#39;演讲&#39;) shuai.interest() shuai.zhuangQian() extends关键字就是继承的重点,但是有一点需要我们注意，TypeScript不支持多重继承。 类方法的重写重写就是在子类中重写父类的方法。例如，我的儿子“技术帅”发现兴趣爱好是找小姐姐，完成不了“”一天赚一个亿“”的目标，它需要多个兴趣，开平台网站。这时候我们就用到了重写。看下面的列子代码： class JsShuai extends Jspang&#123; public xingxiang:string = &#39;帅气&#39; public interest()&#123; super.interest() console.log(&#39;建立电商平台&#39;) &#125; public zhuangQian()&#123; console.log(&#39;一天赚了一个亿&#39;) &#125; &#125; 先是继承了父类的方法，然后通过super关键字调用了父类的方法，实现了技能的增加。 面向对象编程-修饰符public:公有修饰符，可以在类内或者类外使用public修饰的属性或者行为，默认修饰符。protected:受保护的修饰符，可以本类和子类中使用protected修饰的属性和行为。private : 私有修饰符，只可以在类内使用private修饰的属性和行为。readonly :只读属性修饰符,只读属性必须在生命时或者构造函数里被初始化（注意）。 class XiaoJieJie2&#123; public readonly sex:string protected name:string private age:number public constructor(sex:string,name:string,age:number)&#123; this.sex=sex this.name=name this.age=age &#125; public sayHello()&#123; console.log(&#39;小哥哥好&#39;) &#125; protected sayLove()&#123; console.log(&#39;我爱你&#39;) &#125; &#125; var jiejie2:XiaoJieJie2 = new XiaoJieJie2(&#39;女&#39;,&#39;热巴&#39;,22) jiejie2.sex=&#39;男&#39; //报错 console.log(jiejie2.sex) console.log(jiejie2.name) //报错 console.log(jiejie2.age) //报错 jiejie2.sayHello() jiejie2.sayLove() //报错 你可以在写代码的时候，就会发现，编辑器已经给我们报错了。 面向对象编程-接口在通常情况下，接口是用来定义一些规范，使用这些接口，就必须实现按照接口中的规范来走。 在面向对象的语言中，术语interface经常被用来定义一个不包含数据和逻辑代码但是用来签名定义了行为的抽象类型。 认识接口定义接口的关键字是interface。我们现在就来定义一个接口，这个接口是用来规范丈夫的。 interface Husband &#123; sex:string interest:string &#125; let myhusband:Husband =&#123; sex:&#39;男&#39;,interest:&#39;看书、作家务&#39;&#125; console.log(myhusband) 我们通过接口，定义了一个找老公的接口，并且给他了两个必选项：性别和兴趣爱好. 可选参数的接口对老公的标准如果我们有一些可选项，这些并不是都需要显示出来的，在有些情况下，我们只需要传入部分参数。我们可以使用问好的形式来设置可选参数。 比如现在我们还希望老公的标准，有一条是给我“买包包”，但是这个是隐喻的，不是直接显示出来的。我们修改我们的接口。 interface Husband &#123; sex:string interest:string maiBaoBao?:Boolean &#125; let myhusband:Husband =&#123; sex:&#39;男&#39;,interest:&#39;看书、作家务&#39;,maiBaoBao:true&#125; console.log(myhusband) 上面的代码maiBaoBao选项就是可选的，可以写也可以不写。 规范函数类型接口我们还可以使用接口来规范函数类型的接口，比如现在要找老公这件事，我们规定有一些资源，然后我们需要哪些资源，在函数中进行匹配，最后返回是否匹配成功。 interface SearchMan&#123; (source:string,subString:string):boolean &#125; let mySearch:SearchMan mySearch = function(source:string,subString:string):boolean&#123; let flag =source.search(subString) return (flag != -1) &#125; console.log(mySearch(&#39;高、富、帅、德&#39;,&#39;胖&#39;)) //false 接口还可以规范类，但形式都和上满讲的差不多。工作中利用接口就是规范程序标准化使用的，在大团队中经常使用。但是如果是小团队，我觉的接口使用的并不多。 面向对象编程-命名空间在制作大型应用的时候，为了让程序更加有层次感和变量之间不互相干扰，我们可以使用命名空间来构建程序。举个小例子：比如“德华”这件事，帅哥也有叫德华的，二师兄也有叫德华的。那我们要如何区分那。 命名空间的使用当然命名空间就是解决这个问题的，命名空间，又称内部模块，被用于组织有些具有内在联系的特性和对象。我们来看一个例子： namespace shuaiGe&#123; export class Dehua&#123; public name:string = &#39;刘德华&#39; talk()&#123; console.log(&#39;我是帅哥刘德华&#39;) &#125; &#125; &#125; namespace bajie&#123; export class Dehua&#123; public name:string = &#39;马德华&#39; talk()&#123; console.log(&#39;我是二师兄马德华&#39;) &#125; &#125; &#125; let dehua1:shuaiGe.Dehua = new shuaiGe.Dehua() let dehua2:shuaiGe.Dehua = new bajie.Dehua() dehua1.talk() 程序我会在视频中详细讲解，通过命名空间我们很好的把程序变的清晰了，各位小姐姐也再也不会刘德华和马德华傻傻分不清了。","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"}]},{"title":"Flutter","slug":"code/flutter","date":"2019-12-31T02:54:00.000Z","updated":"2021-05-19T11:18:03.695Z","comments":true,"path":"2019/12/31/code/flutter/","link":"","permalink":"http://yoursite.com/2019/12/31/code/flutter/","excerpt":"","text":"了解FlutterFlutter的优点非常明显，如果你选择一个跨平台框架，与众多基于html的跨平台框架相比，Flutter绝对是体验最好，性能与构建思路几乎最接近原生开发的框架。性能强大，流畅路由设计优秀优秀的动画设计 环境搭建windows环境JAVA环境安装java下载 环境变量-系统变量中新增 Name Description Remark JAVA_HOME C:\\Program Files (x86)\\Java\\jdk1.8.0_91 实际java安装jdk路径 CLASSPATH .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; 记得前面有个”.” Path %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; 首选确保jdk与jre是在同一个文件夹下 Flutter环境安装flutter sdk下载 选择稳定版本下载后解压至文件夹然后在系统变量 Path 中增加路径 Path ： C:\\_Software\\flutter\\bin Android Studio安装Android Studio 下载Android Studio安装教程 打开Android Studio 依次打开file-&gt;setting-&gt;Plugins 在右侧搜索Flutter并安装 安装Android证书运行 flutter doctor --android-licenses 全程确定终端输入 flutter doctor -v 进行测试 看是否有报错信息如果提示没有虚拟机可以用VScode直接打开flutter项目然后可以在右下角直接新建一个虚拟机项目创建需要使用 Android Studio 创建flutter项目。 疑难杂症 如果报错main就尝试修改Android studio里面的java路径。 如果报错java_home文件夹不对的话就修改文件中的java_home路径 安装证书错误window 安装证书错误mac 如果是Android的翻墙问题则全都改为阿里的链接。 验证输入命令 java -version、java、javac等有反应，说明环境变量配置成功； VScode开发配置安装 Flutter 插件 常用命令 flutter run 开始运行项目 r 键：点击后热加载，也就算是重新加载吧。 p 键：显示网格，这个可以很好的掌握布局情况，工作中很有用。 o 键：切换android和ios的预览模式。 q 键：退出调试预览模式。 开启Debug模式，这时就可以实现真正的热加载了（我们保存，效果立即就会改变） 使用 flutter upgrade 命令升级到最新版本。 初步了解 所有的数字必须至少精确到小数点后一位 class retrun的函数最后一定要加上 ; 容器对应了解注意 Flutter H5 Text span Container div Image img ListView 静态列表 GridView 动态列表 加入图片的几种形式Image.asset:加载资源图片，就是加载项目资源目录中的图片,加入图片后会增大打包的包体体积，用的是相对路径。Image.network:网络资源图片，意思就是你需要加入一段http://xxxx.xxx的这样的网络路径地址。Image.file:加载本地图片，就是加载本地文件中的图片，这个是一个绝对路径，跟包体无关。 定义var myList = List(): 非固定长度的声明。 var myList = List(2): 固定长度的声明。 var myList= List&lt;String&gt;():固定类型的声明方式。 var myList = [1,2,3]: 对List直接赋值。 动态列表import &#39;package:flutter/material.dart&#39;; void main () =&gt; runApp(MyApp( items: new List&lt;String&gt;.generate(1000, (i)=&gt; &quot;Item $i&quot;)//生成1000个数组，内容是Item +下标 )); class MyApp extends StatelessWidget&#123; final List&lt;String&gt; items;//定义数组变量 MyApp(&#123;Key key, @required this.items&#125;):super(key:key);//接受传入的数组 @override Widget build(BuildContext context )&#123; return MaterialApp( title:&#39;ListView widget&#39;, home:Scaffold( body:new ListView.builder( itemCount:items.length, itemBuilder:(context,index)&#123;//遍历 return new ListTile( title:new Text(&#39;$&#123;items[index]&#125;&#39;), ); &#125; ) ), ); &#125; &#125; 网格列表组件import &#39;package:flutter/material.dart&#39;; void main() =&gt; runApp(MyApp()); class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &quot;listView widget&quot;, home: Scaffold( body: GridView( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 3,//一行几个 mainAxisSpacing: 2.0,//上下间距 crossAxisSpacing: 2.0,//左右列表间距 childAspectRatio: 0.516),//宽高比 children: &lt;Widget&gt;[ new Image.network(&#39;http://img5.mtime.cn/mt/2018/10/22/104316.77318635_180X260X4.jpg&#39;,fit: BoxFit.cover), new Image.network(&#39;http://img5.mtime.cn/mt/2018/10/22/104316.77318635_180X260X4.jpg&#39;,fit: BoxFit.cover), new Image.network(&#39;http://img5.mtime.cn/mt/2018/10/22/104316.77318635_180X260X4.jpg&#39;,fit: BoxFit.cover), new Image.network(&#39;http://img5.mtime.cn/mt/2018/10/22/104316.77318635_180X260X4.jpg&#39;,fit: BoxFit.cover), new Image.network(&#39;http://img5.mtime.cn/mt/2018/10/22/104316.77318635_180X260X4.jpg&#39;,fit: BoxFit.cover), new Image.network(&#39;http://img5.mtime.cn/mt/2018/10/22/104316.77318635_180X260X4.jpg&#39;,fit: BoxFit.cover), new Image.network(&#39;http://img5.mtime.cn/mt/2018/10/22/104316.77318635_180X260X4.jpg&#39;,fit: BoxFit.cover), new Image.network(&#39;http://img5.mtime.cn/mt/2018/10/22/104316.77318635_180X260X4.jpg&#39;,fit: BoxFit.cover), new Image.network(&#39;http://img5.mtime.cn/mt/2018/10/22/104316.77318635_180X260X4.jpg&#39;,fit: BoxFit.cover), ], ), ), ); &#125; &#125; 水平布局Flutter中的row控件就是水平控件，它可以让Row里边的子元素进行水平排列。 Row控件可以分为灵活排列和非灵活排列两种。Row自带的方式会按照元素本身大小排列，却不会充满。Expanded扩展组件类似flex:1。 class MyApp2 extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &quot;listView widget&quot;, home: Scaffold( appBar: new AppBar( title: new Text(&quot;水平方向布局&quot;), ), body: new Row( children: &lt;Widget&gt;[ new RaisedButton( onPressed: () &#123;&#125;, color: Colors.redAccent, child: new Text(&quot;红色按钮&quot;), ), Expanded( //扩展组件可以填满剩下的空间。类似flex:1 child: new RaisedButton( onPressed: () &#123;&#125;, color: Colors.orangeAccent, child: new Text(&quot;黄色按钮&quot;), ), ), new RaisedButton( onPressed: () &#123;&#125;, color: Colors.pinkAccent, child: new Text(&quot;粉色按钮&quot;), ), ], ), )); &#125; &#125; 垂直布局CrossAxisAlignment.star：居左对齐。CrossAxisAlignment.end：居右对齐。CrossAxisAlignment.center：居中对齐。 主轴和副轴的辨识在设置对齐方式的时候你会发现右mainAxisAlignment属性，意思就是主轴对齐方式，那什么是主轴，什么又是幅轴那。 main轴：如果你用column组件，那垂直就是主轴，如果你用Row组件，那水平就是主轴。 cross轴：cross轴我们称为幅轴，是和主轴垂直的方向。比如Row组件，那垂直就是幅轴，Column组件的幅轴就是水平方向的。 主轴和幅轴我们搞清楚，才能在实际工作中随心所欲的进行布局。 mainAxisAlignment: MainAxisAlignment.center, class MyApp3 extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &quot;List View widget&quot;, home: Scaffold( appBar: new AppBar( title: new Text(&quot;垂直方向布局&quot;), ), body: Column( // 交叉轴/横轴/副轴对齐 cross是副轴的意思方向看容器而言 crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Center( child: Text(&quot;i love money&quot;), ), Expanded( child: Text(&quot;i very love swim&quot;), ), Center( child: Text(&quot;i love china&quot;), ), ], ), )); &#125; &#125; 层叠布局层叠布局的 alignment 属性alignment属性是控制层叠的位置的，建议在两个内容进行层叠时使用。它有两个值X轴距离和Y轴距离，值是从0到1的，都是从上层容器的左上角开始算起的。Positioned组件的属性bottom: 距离层叠组件下边的距离left：距离层叠组件左边的距离top：距离层叠组件上边的距离right：距离层叠组件右边的距离width: 层叠定位组件的宽度height: 层叠定位组件的高度 class MyApp4 extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &quot;listView&quot;, home: Scaffold( appBar: new AppBar( title: new Text(&quot;垂直布局&quot;), ), body: Center( child: new Stack( //叠放的意思，层叠组件多个层叠 alignment: const FractionalOffset(0.5, 0.8), //传入坐标比例 children: &lt;Widget&gt;[ new CircleAvatar( backgroundImage: new NetworkImage( &quot;https://cdn.jsdelivr.net/gh/dxc0522/cdn_assets@3.7/img/custom/avatar.jpeg&quot;), radius: 50.0, ), new Container( decoration: new BoxDecoration(color: Colors.lightBlue), padding: EdgeInsets.all(5.0), child: new Text(&#39;娃哈哈&#39;), ), new Positioned( //定位组件，自行更改位置 top: 10.0, left: 10.0, child: new Text(&quot;第一行&quot;), ), new Positioned( top: 30.0, left: 10.0, child: new Text(&quot;第二行&quot;), ), ], ), ), ), ); &#125; &#125; 卡片布局卡片式布局默认是撑满整个外部容器的，如果你想设置卡片的宽高，需要在外部容器就进行制定。代码中使用了一个垂直布局组件Column组件，然后利用了ListTile实现内部列表，这里需要说明的是ListTile不光可以使用在ListView组件中，然后容器组件其实都可以使用. class MyApp5 extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var card = new Card( child: Column( children: &lt;Widget&gt;[ ListTile( title: new Text( &quot;河南省漯河市&quot;, style: TextStyle(fontWeight: FontWeight.w500), ), subtitle: new Text(&quot;doudou&quot;), leading: new Icon( Icons.account_box, color: Colors.lightBlue, ), ), new Divider(),//下划线 ListTile( title: new Text( &quot;河南省漯河市&quot;, style: TextStyle(fontWeight: FontWeight.w500), ), subtitle: new Text(&quot;doudou&quot;), leading: new Icon( Icons.account_box, color: Colors.lightBlue, ), ), new Divider(), ], ), ); return MaterialApp( title: &quot;list view&quot;, home: Scaffold( appBar: new AppBar( title: new Text(&quot;卡片布局&quot;), ), body: Center( child: card, ), ), ); &#125; &#125; 跳转Navigator.push 和 Navigator.popNavigator.push：是跳转到下一个页面，它要接受两个参数一个是上下文context，另一个是要跳转的函数。 Navigator.pop：是返回到上一个页面，使用时传递一个context（上下文）参数，使用时要注意的是，你必须是有上级页面的，也就是说上级页面使用了Navigator.push。 import &#39;package:flutter/material.dart&#39;; void main() &#123; runApp(MaterialApp( title: &quot;导航演示&quot;, home: new FristScreen(), )); &#125; class FristScreen extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: new AppBar( title: new Text(&quot;导航页面&quot;), ), body: Center( child: new RaisedButton( child: Text(&quot;查看商品详情&quot;), onPressed: () &#123; Navigator.push( context, new MaterialPageRoute( builder: (context) =&gt; new SecondScreen())); &#125;, ), ), ); &#125; &#125; class SecondScreen extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: new AppBar( title: new Text(&quot;详情页&quot;), ), body: Center( child: RaisedButton( child: Text(&quot;返回&quot;), onPressed: () &#123; Navigator.pop(context); &#125;, ), ), ); &#125; &#125; 参数传递与接收声明数据结构类Dart中可以使用类来抽象一个数据，比如我们模仿一个商品信息，有商品标题和商品描述。我们定义了一个Product类，里边有两个字符型变量，title和description。 title:是商品标题。description: 商品详情描述 import &#39;package:flutter/material.dart&#39;; // 路由参数传递 // 定义数据类型 class Product &#123; final String title; final String description; Product(this.title, this.description); &#125; // 生成数据列表 void main() &#123; // 传递参数到页面 runApp(MaterialApp( title: &quot;数据传递案例&quot;, home: ProductList( products: List.generate( 20, (i) =&gt; Product(&#39;商品 $i&#39;, &quot;这是一个商品详情，编号为 :$i&quot;))), //List.generate生成数据 )); &#125; class ProductList extends StatelessWidget &#123; // 定义参数 final List&lt;Product&gt; products; // 接收参数 ProductList(&#123;Key key, @required this.products&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(title: Text(&quot;商品列表&quot;)), body: ListView.builder( itemCount: products.length, itemBuilder: (context, index) &#123; return ListTile( title: Text(products[index].title), onTap: () &#123; // 跳转传参 Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; new ProductDetail( product: products[index], ))); &#125;, ); &#125;, ), ); &#125; &#125; // 接收页面 class ProductDetail extends StatelessWidget &#123; final Product product;//定义参数 ProductDetail(&#123;Key key, @required this.product&#125;) : super(key: key);//接收参数 @override Widget build(BuildContext context) &#123; return new Scaffold( appBar: AppBar( title: Text(&quot;$&#123;product.title&#125;&quot;), ), body: Center( child: Text(&#39;$&#123;product.description&#125;&#39;), ), ); &#125; &#125; 页面跳转并返回数据SnackBar的使用SnackBar是用户操作后，显示提示信息的一个控件，类似Tost，会自动隐藏。SnackBar是以Scaffold的showSnackBar方法来进行显示的。Scaffold.of(context).showSnackBar(SnackBar(content:Text(‘$result’)));返回数据的方式返回数据其实是特别容易的，只要在返回时带第二个参数就可以了。 Navigator.pop(context,’xxxx’); //xxx就是返回的参数 import &#39;package:flutter/material.dart&#39;; void main() &#123; runApp(MaterialApp(title: &quot;页面跳转返回值&quot;, home: FirstPage())); //意思好像是只有一层路由就没法往回退of了，所以要加一个基础的widget在runApp &#125; class FirstPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(&quot;去要号码&quot;), ), body: Column( children: &lt;Widget&gt;[ RouterButton(), Image.asset( &quot;img/jd.png&quot;, width: 100.0, height: 100.0, ), Image.asset( &quot;img/jd.png&quot;, width: 100.0, height: 100.0, ), ], )); &#125; &#125; class RouterButton extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return RaisedButton( onPressed: () &#123; _navigateToGetNumber(context); &#125;, child: Text(&quot;点击跳转要号码&quot;), ); &#125; // 自有方法的调用 _navigateToGetNumber(BuildContext context) async &#123; final result = await Navigator.push( context, MaterialPageRoute(builder: (context) =&gt; SecendPage())); // showSnackBar为展示弹框记录下个页面退出后的返回值 Scaffold.of(context).showSnackBar(SnackBar( content: Text(&quot;$result&quot;), )); //意思好像是只有一层路由就没法往回退of了，所以要加一个基础的widget在runApp &#125; &#125; class SecendPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: new Text(&quot;我是号码页面&quot;), ), body: Center( child: Column( children: &lt;Widget&gt;[ RaisedButton( child: Text(&quot;一号种子选手&quot;), onPressed: () &#123; // 返回上一页，并且带参数 Navigator.pop(context, &#39;一号：111111&#39;); &#125;, ), RaisedButton( child: Text(&quot;二号种子选手&quot;), onPressed: () &#123; Navigator.pop(context, &#39;三号：222222&#39;); &#125;, ), RaisedButton( child: Text(&quot;三号种子选手&quot;), onPressed: () &#123; Navigator.pop(context, &#39;三号：333333&#39;); &#125;, ), ], ), ), ); &#125; &#125; 静态资源声明项目资源如果想配置项目资源文件，就需要使用pubspec.yaml文件，需要把资源文件在这里声明。 比如在项目根目录下新建了一个images文件夹，文件夹下面放了一个图片，图片的名称叫做blogtouxiang.jpg，那我们在pubspec.yaml文件里就要写如下代码进行声明。 assets: - images/blogtouxiang.jpg 使用项目图片资源有了声明后，我们就可以直接在项目中引用这个文件了。这里使用最简单的代码结构，只用了一张图片。代码如下: import &#39;package:flutter/material.dart&#39;; void main()=&gt;runApp(MyApp()); class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Container( child: Image.asset(&#39;images/blogtouxiang.jpg&#39;), ); &#125; &#125; 客户端打包配置APP的图标想配置APP的图片，你需要找到下面的目录： 项目根目录/android/app/src/main/res/ 进入之后你会看到很多mipmap-为前缀命名的文件夹，后边的是像素密度，可以看出图标的分辨率。 mdpi (中) ~160dpihdpi （高） ~240dipxhdpi （超高） ~320dipxxhdpi （超超高） ~480dipxxxhdpi （超超超高） ~640dip将对应像素密度的图片放入对应的文件夹中,图片记得用png格式，记得名字要统一，才能一次性进行配置。 AndroidManifest.xml 文件这个文件主要用来配置APP的名称、图标和系统权限，所在的目录在: 项目根目录/android/app/src/main/AndroidManifest.xml android:label=&quot;flutter_app&quot; //配置APP的名称，支持中文 android:icon=&quot;@mipmap/ic_launcher&quot; //APP图标的文件名称 生成 keystore这里的坑挺多的，小伙伴一定要注意。官方写的非常简单，只要在终端运行如下代码就可以成功,但事实是报错。 keytool -genkey -v -keystore ~/key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key 根本找不到这个目录，真的很坑，其实我们只是没有配置环境变量。但是为了一个包配置环境变量是不知道的。 这时候可以用下面的命令找到keytool.exe的位置。 flutter doctor -v 这时候你直接拷贝命令并进行输入，但这里也有个坑，就是如果文件夹中间带有空空，你需要用带引号扩上。 D:\\Program\\Android\\&#39;Android Studio&#39;\\jre\\bin\\keytool -genkey -v -keystore ~/key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key这就可以了吗？那你就太天真了，还是会报错。 如果是目录不存在和没有写权限，所以我们要更换一个有写权限的目录。我们把命令改成了下面的形式。 D:\\Program\\Android\\&#39;Android Studio&#39;\\jre\\bin\\keytool -genkey -v -keystore D:\\key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key这时候就可以创建成功了。你的D盘下面就会有一个Jks的文件，记住这个文件不能共享给任何人。 有了这个key.jks文件后，可以到项目目录下的android文件夹下，创建一个名为key.properties的文件，并打开粘贴下面的代码。 storePassword=123123 //输入上一步创建KEY时输入的 密钥库 密码 keyPassword=123123 //输入上一步创建KEY时输入的 密钥 密码 keyAlias=key storeFile=D:/key.jks //key.jks的存放路径 这个工作中也不要分享出去哦，这个Key就算生成成功了。 配置key注册key生成好后，需要在build.gradle文件中进行配置。这个过程其实很简单，就是粘贴复制一些东西，你是不需要知道这些文件的具体用处的。 第一项： 进入项目目录的/android/app/build.gradle文件，在android&#123;这一行前面,加入如下代码： def keystorePropertiesFile = rootProject.file(&quot;key.properties&quot;) def keystoreProperties = new Properties() keystoreProperties.load(new FileInputStream(keystorePropertiesFile)) 把如下代码进行替换 buildTypes &#123; release &#123; signingConfig signingConfigs.debug &#125; &#125; 替换成的代码： signingConfigs &#123; release &#123; keyAlias keystoreProperties[&#39;keyAlias&#39;] keyPassword keystoreProperties[&#39;keyPassword&#39;] storeFile file(keystoreProperties[&#39;storeFile&#39;]) storePassword keystoreProperties[&#39;storePassword&#39;] &#125; &#125; buildTypes &#123; release &#123; signingConfig signingConfigs.release &#125; &#125; 错误情况如果报错找不到文件，或者一直提示密码错误，直接修改文件/android/app/build.gradle并且将key文件放到android/app/目录内即可 signingConfigs &#123; release &#123; keyAlias &quot;key&quot; keyPassword &quot;123456&quot; storeFile file(&quot;./key.jks&quot;) storePassword &quot;123456&quot; &#125; &#125; 生成apk直接在终端中输入： flutter build apk 直接安装到虚拟机 Flutter install 常见底部导航制作引入文件编写 import &#39;package:flutter/material.dart&#39;; import &#39;bottom_navigation_widget.dart&#39;; void main() =&gt; runApp(MyApp()); class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &quot;flutter bottom navigationbar&quot;, theme: ThemeData.light(), home: BottomNavigationWidget(), ); &#125; &#125; StatefulWidgetStatefulWidget具有可变状态(state)的窗口组件（widget）。使用这个要根据变化状态，调整State值。是编写组件的最佳方法。快捷方式stful. 在lib目录下，新建一个bottom_navigation_widget.dart文件。 它的初始化和以前使用的StatelessWidget不同 下面的代码可以清楚的看到，使用StatefulWidget分为两个部分，第一个部分是继承与StatefullWidget，第二个部分是继承于State.其实State部分才是我们的重点，主要的代码都会写在State中。..add()是Dart语言的..语法就是返回调用者本身。这里list后用了..add()，还会返回list，然后就一直使用..语法，能一直想list里增加widget元素。 最后我们调用了一些父类的initState()方法。 import &#39;package:flutter/material.dart&#39;; import &#39;home_screen.dart&#39;;//引入不同的页面 import &#39;pages_screen.dart&#39;; import &#39;email_screen.dart&#39;; import &#39;airplay_screen.dart&#39;; class BottomNavigationWidget extends StatefulWidget &#123; @override _BottomNavigationWidgetState createState() =&gt; _BottomNavigationWidgetState(); &#125; class _BottomNavigationWidgetState extends State&lt;BottomNavigationWidget&gt; &#123; // 定义同一颜色 final _BottomNavigationColor = Colors.blue; // 定义下标 int _currentIndex = 0; // 定义页面列表 List&lt;Widget&gt; list = List(); @override // 扩展运算填入页面赋值给list void initState() &#123; list ..add(HomeScreen()) ..add(EmailScreen()) ..add(PagesScreen()) ..add(AirplayScreen()); super.initState(); &#125; Widget build(BuildContext context) &#123; return Scaffold( body: list[_currentIndex], // 根据下标展示页面 bottomNavigationBar: BottomNavigationBar( items: [ BottomNavigationBarItem( icon: Icon(Icons.home, color: _BottomNavigationColor), title: Text(&quot;Home&quot;, style: TextStyle(color: _BottomNavigationColor))), BottomNavigationBarItem( icon: Icon(Icons.email, color: _BottomNavigationColor), title: Text(&quot;Email&quot;, style: TextStyle(color: _BottomNavigationColor))), BottomNavigationBarItem( icon: Icon(Icons.pages, color: _BottomNavigationColor), title: Text(&quot;Pages&quot;, style: TextStyle(color: _BottomNavigationColor))), BottomNavigationBarItem( icon: Icon(Icons.airplay, color: _BottomNavigationColor), title: Text(&quot;Airplay&quot;, style: TextStyle(color: _BottomNavigationColor))), ], currentIndex: _currentIndex, // 显示指定下标 onTap: (int index) &#123; // 点击方法并定义接收参数 setState(() &#123; _currentIndex = index; &#125;); &#125;, ), ); &#125; &#125; 不规则底部工具栏制作 （圆形按钮）自定义主题样本Flutter支持自定义主题，如果使用自定义主题，设置的内容项是非常多的，这可能让初学者头疼，Flutter贴心的为给我们准备了主题样本。 primarySwatch ：现在支持18种主题样本了。 具体代码如下： theme: ThemeData( primarySwatch: Colors.lightBlue, ), 主入口文件 import &#39;package:flutter/material.dart&#39;; import &#39;bottom_appbar_demo.dart&#39;; void main() =&gt; runApp(MyApp()); class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &quot;flutter bottom navigationbar&quot;, // 主题颜色 theme: ThemeData(primarySwatch: Colors.lightBlue), home: BottomAppBarDemo(), ); &#125; &#125; floatingActionButton Widget (活动浮动按钮)floatingActionButton工作中我们通常简称它为“FAB”，也许只是我们公司这样称呼，从字面理解可以看出，它是“可交互的浮动按钮”,其实在Flutter默认生成的代码中就有这家伙，只是我们没有正式的接触。 一般来说，它是一个圆形，中间放着图标，会优先显示在其他Widget的前面。 下面我们来看看它的常用属性: onPressed ：点击相应事件，最常用的一个属性。 tooltip：长按显示的提示文字，因为一般只放一个图标在上面，防止用户不知道，当我们点击长按时就会出现一段文字性解释。非常友好，不妨碍整体布局。 child ：放置子元素，一般放置Icon Widget。3 悬浮按钮还没有和低栏进行融合，这时候需要一个属性。floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,这时候就可以和底栏进行融合了。 BottomAppBar WidgetBottomAppBar 是 底部工具栏的意思，这个要比BottomNavigationBar widget灵活很多，可以放置文字和图标，当然也可以放置容器。 BottomAppBar的常用属性: color:这个不用多说，底部工具栏的颜色。shape：设置底栏的形状，一般使用这个都是为了和floatingActionButton融合，所以使用的值都是CircularNotchedRectangle(),有缺口的圆形矩形。child ： 里边可以放置大部分Widget，让我们随心所欲的设计底栏。 组件子页面新建一个each_view.dart文件，然后输入如下代码： import &#39;package:flutter/material.dart&#39;; class EachView extends StatefulWidget &#123; String _title; EachView(this._title); @override _EachViewState createState() =&gt; _EachViewState(); &#125; class _EachViewState extends State&lt;EachView&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar:AppBar(title:Text(widget._title)), body: Center(child:Text(widget._title)), ); &#125; &#125; 代码中设置了一个内部的_title变量，这个变量是从主页面传递过来的，然后根据传递过来的具体值显示在APP的标题栏和屏幕中间。 底部按钮组件import &#39;package:flutter/material.dart&#39;; import &#39;each_view.dart&#39;; class BottomAppBarDemo extends StatefulWidget &#123; @override _BottomAppBarDemoState createState() =&gt; _BottomAppBarDemoState(); &#125; class _BottomAppBarDemoState extends State&lt;BottomAppBarDemo&gt; &#123; List&lt;Widget&gt; _eachView; //创建视图数组 int _index = 0; //数组索引，通过改变索引值改变视图 @override void initState() &#123; //重写初始化方法 super.initState(); _eachView = List(); _eachView..add(EachView(&quot;home&quot;))..add(EachView(&quot;Me&quot;)); &#125; Widget build(BuildContext context) &#123; return Scaffold( body: _eachView[_index], // 浮动按钮 floatingActionButton: FloatingActionButton( onPressed: () &#123; Navigator.of(context) .push(MaterialPageRoute(builder: (BuildContext context) &#123; return EachView(&quot;New Page&quot;); //返回页面 &#125;)); &#125;, tooltip: &quot;Increment&quot;, // 工具提示 child: Icon( Icons.add, color: Colors.white, ), ), // 浮动按钮位置：中心对接 floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, bottomNavigationBar: BottomAppBar( color: Colors.lightBlue, shape: CircularNotchedRectangle(), // 形状：圆形缺口矩阵 child: Row( // 主轴大小 mainAxisSize: MainAxisSize.max, // 主轴对齐方式 mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ IconButton( icon: Icon(Icons.home), color: Colors.white, onPressed: () &#123; setState(() &#123; _index = 0; &#125;); &#125;, ), IconButton( icon: Icon(Icons.airport_shuttle), color: Colors.white, onPressed: () &#123; setState(() &#123; _index = 1; &#125;); &#125;, ), ], ), ), ); &#125; &#125; 炫酷的路由动画","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"App","slug":"App","permalink":"http://yoursite.com/tags/App/"}]},{"title":"Nginx","slug":"code/nginx","date":"2019-12-20T08:30:00.000Z","updated":"2021-05-19T11:18:03.697Z","comments":true,"path":"2019/12/20/code/nginx/","link":"","permalink":"http://yoursite.com/2019/12/20/code/nginx/","excerpt":"","text":"了解Nginx是一款轻量级的HTTP服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的IO性能，时常用于服务端的反向代理和负载均衡。Nginx的优点• 支持海量高并发：采用IO多路复用epoll。官方测试Nginx能够支持5万并发链接，实际生产环境中可以支撑2-4万并发连接数。• 内存消耗少：在主流的服务器中Nginx目前是内存消耗最小的了，比如我们用Nginx+PHP，在3万并发链接下，开启10个Nginx进程消耗150M内存。• 免费使用可以商业化：Nginx为开源软件，采用的是2-clause BSD-like协议，可以免费使用，并且可以用于商业。• 配置文件简单：网络和程序配置通俗易懂，即使非专业运维也能看懂。当然它的有点还有很多，比如反向代理功能，负载均衡功能Nginx版本说明• Mainline version ：开发版,主要是给广大Nginx爱好者，测试、研究和学习的，但是不建议使用于生产环境。• Stable version : 稳定版,也就是我们说的长期更新版本。这种版本一般比较成熟，经过长时间的更新测试，所以这种版本也是主流版本。• legacy version : 历史版本，如果你需要以前的版本，Nginx也是有提供的。 安装/卸载基于Yum的方式安装Nginx安装必要程序 yum -y install gcc gcc-c++ autoconf pcre-devel make automake yum -y install wget httpd-tools vim 我们可以先来查看一下yum是否已经存在 yum list | grep nginx但是yum中的版本一般比较低需要重新设置yum源进入 Nginx 官网查找最新稳定版本的 复制这段代码 然后在服务器终端里输入 vim /etc/yum.repos.d/nginx.repo 然后把代码复制进去，复制完成后，你需要修改一下对应的操作系统和版本号，因为我的是centos和7的版本，所以改为这样。 baseurl=http://nginx.org/packages/centos/7/$basearch/你可以根据你的系统或需要的版本进行修改。可以再次查看Nginx列表就可看到最新的如果都已经准备好了，那就可以开始安装了，安装的命令非常简单：yum install nginx安装完成后可以使用命令，来检测Nginx的版本。 nginx -v 如果查询到版本则安装成功。 卸载第一步：输入以下指令全局查找nginx相关的文件： sudo find / -name nginx*第二步：删除查找出来的所有nginx相关文件 sudo rm -rf file 此处跟查找出来的nginx文件说明：全局查找往往会查出很多相关文件，但是前缀基本都是相同，后面不同的部分可以用*代替，以便快速删除~ apt-get remove nginx* 原理就是删除关联文件以及文件夹。举例说明：sudo rm -rf file /usr/local/nginx*删除之后，便可重新安装nginx了 配置文件命令行运行 rpm -ql nginxrpm 是linux的rpm包管理工具，-q 代表询问模式，-l 代表返回列表，这样我们就可以找到nginx的所有安装位置了。nginx.conf 文件解读nginx.conf 文件是Nginx总配置文件，在我们搭建服务器时经常调整的文件。进入 etc/nginx 目录下，然后用vim进行打开 cd /etc/nginx vim nginx.conf 配置文件 # 运行用户，默认即是nginx，可以不进行设置 user nginx; # Nginx进程，一般设置为和CPU核数一样 worker_processes 1; # 错误日志存放目录 error_log /var/log/nginx/error.log warn; # 进程pid存放位置 pid /var/run/nginx.pid; events &#123; worker_connections 1024; # 单个后台进程的最大并发数 &#125; http &#123; include /etc/nginx/mime.types; #文件扩展名与类型映射表 default_type application/octet-stream; #默认文件类型 #设置日志模式 log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; access_log /var/log/nginx/access.log main; #nginx访问日志存放位置 sendfile on; #开启高效传输模式 tcp_nopush on; #减少网络报文段的数量 keepalive_timeout 65; #保持连接的时间，也叫超时时间 gzip on; #开启gzip压缩 include /etc/nginx/conf.d/*.conf; #包含的子配置项位置和文件 server &#123; listen 80; #配置监听端口 server_name localhost; #配置域名 charset koi8-r; access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; #服务默认启动目录 index index.html index.htm; #默认访问文件 &#125; error_page 404 /404.html; # 配置404页面 redirect server error pages to the static page /50x.html error_page 500 502 503 504 /50x.html; #错误状态码的显示页面，配置后需要重启 location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#39;s document root # concurs with nginx&#39;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; &#125; 明白了这些配置项，我们知道我们的服务目录放在了/usr/share/nginx/html下，可以使用命令进入看一下目录下的文件。 ls /usr/share/nginx/html可以看到目录下面有两个文件，50x.html 和 index.html。我们可以使用vim进行编辑。可以直接开启服务查看效果但是需要开启端口，本地虚拟机的端口开启方式 开启端口阿里云的安全组配置如果你使用的是阿里云，记得到ECS实例一下打开端口。步骤如下： 进入阿里云控制台，并找到ECS实例。 点击实例后边的“更多” 点击“网络和安全组” ，再点击“安全组配置” 右上角添加“安全组配置” 进行80端口的设置，具体设置如图就好。 如果访问域名可以查看到页面就正常运行了。 命令启动Nginx服务默认的情况下，Nginx是不会自动启动的，需要我们手动进行启动，当然启动Nginx的方法也不是单一的。 nginx直接启动在CentOS7.4版本里（低版本是不行的），是可以直接直接使用nginx启动服务的。 nginx 使用systemctl命令启动还可以使用个Linux的命令进行启动，我一般都是采用这种方法进行使用。因为这种方法无论启动什么服务，都是一样的，只是换一下服务的名字（不用增加额外的记忆点）。systemctl start nginx.service 输入命令后，没有任何提示，那我们如何知道Nginx服务已经启动了哪？可以使用Linux的组合命令，进行查询服务的运行状况。 ps aux | grep nginx如果启动成功会出现如下图片中类似的结果。 有这三条记录，说明我们Nginx被正常开启了。 停止Nginx服务的四种方法停止Nginx 方法有很多种，可以根据需求采用不一样的方法，我们一个一个说明。 立即停止服务 nginx -s stop这种方法比较强硬，无论进程是否在工作，都直接停止进程。 从容停止服务nginx -s quit这种方法较stop相比就比较温和一些了，需要进程完成当前工作后再停止。 killall 方法杀死进程这种方法也是比较野蛮的，我们直接杀死进程，但是在上面使用没有效果时，我们用这种方法还是比较好的。killall nginx systemctl 停止 systemctl stop nginx.service 重启Nginx服务有时候我们需要重启Nginx服务，这时候可以使用下面的命令。 systemctl restart nginx.service 重新载入配置文件在重新编写或者修改Nginx的配置文件后，都需要作一下重新载入，这时候可以用Nginx给的命令。 nginx -s reload 查看端口号在默认情况下，Nginx启动后会监听80端口，从而提供HTTP访问，如果80端口已经被占用则会启动失败。我么可以使用netstat -tlnp命令查看端口号的占用情况。 错误页面配置多错误指向一个页面在/etc/nginx/conf.d/default.conf 是可以看到下面这句话的。error_page 500 502 503 504 /50x.html;error_page指令用于自定义错误页面，500，502，503，504 这些就是HTTP中最常见的错误代码，/50.html 用于表示当发生上述指定的任意一个错误的时候，都是用网站根目录下的/50.html文件进行处理。 单独为错误置顶处理方式有些时候是要把这些错误页面单独的表现出来，给用户更好的体验。所以就要为每个错误码设置不同的页面。设置方法如下：error_page 404 /404_error.html;然后到网站目录下新建一个404_error.html 文件，并写入一些信息。 &lt;html&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;body&gt; &lt;h1&gt;404页面没有找到!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 然后重启我们的服务，再进行访问，你会发现404页面发生了变化。 把错误码换成一个地址处理错误的时候，不仅可以只使用本服务器的资源，还可以使用外部的资源。比如我们将配置文件设置成这样。error_page 404 http://jspang.com;我们使用了技术胖的博客地址作为404页面没有找到的提示，就形成了，没有找到文件，就直接跳到了技术胖的博客上了。 访问权限简单实现访问控制有时候我们的服务器只允许特定主机访问，比如内部OA系统，或者应用的管理后台系统，更或者是某些应用接口，这时候我们就需要控制一些IP访问，我们可以直接在location里进行配置。可以直接在default.conf里进行配置。 location / &#123; deny 123.9.51.42; #拒绝 allow 45.76.202.231; #仅允许 &#125; 配置完成后，重启一下服务器就可以实现限制和允许访问了。 指令优先级我们先来看一下代码： location / &#123; allow 45.76.202.231; deny all; &#125; 上面的配置表示只允许45.76.202.231进行访问，其他的IP是禁止访问的。但是如果我们把deny all指令，移动到 allow 45.76.202.231之前，会发生什么那？会发现所有的IP都不允许访问了。这说明了一个问题：就是在同一个块下的两个权限指令，先出现的设置会覆盖后出现的设置（也就是谁先触发，谁起作用）。 复杂访问控制权限匹配在工作中，访问权限的控制需求更加复杂，例如，对于网站下的img（图片目录）是运行所有用户访问，但对于网站下的admin目录则只允许公司内部固定IP访问。这时候仅靠deny和allow这两个指令，是无法实现的。我们需要location块来完成相关的需求匹配。上面的需求，配置代码如下： location =/img&#123; allow all; &#125; location =/admin&#123; deny all; &#125; =号代表精确匹配，使用了=后是根据其后的模式进行精确匹配。这个直接关系到我们网站的安全，一定要学会。 使用正则表达式设置访问权限只有精确匹配有时是完不成我们的工作任务的，比如现在我们要禁止访问所有php的页面，php的页面大多是后台的管理或者接口代码，所以为了安全我们经常要禁止所有用户访问，而只开放公司内部访问的。代码如下： location ~\\.php$ &#123; deny all; &#125; 这样我们再访问的时候就不能访问以php结尾的文件了。是不是让网站变的安全很多了那 虚拟主机虚拟主机是指在一台物理主机服务器上划分出多个磁盘空间，每个磁盘空间都是一个虚拟主机，每台虚拟主机都可以对外提供Web服务，并且互不干扰。在外界看来，虚拟主机就是一台独立的服务器主机，这意味着用户能够利用虚拟主机把多个不同域名的网站部署在同一台服务器上，而不必再为简历一个网站单独购买一台服务器，既解决了维护服务器技术的难题，同时又极大地节省了服务器硬件成本和相关的维护费用。 基于端口号配置虚拟主机基于端口号来配置虚拟主机，算是Nginx中最简单的一种方式了。原理就是Nginx监听多个端口，根据不同的端口号，来区分不同的网站。 我们可以直接配置在主文件里etc/nginx/nginx.conf文件里， 也可以配置在子配置文件里etc/nginx/conf.d/default.conf。我这里为了配置方便，就配置在子文件里了。当然你也可以再新建一个文件，只要在conf.d文件夹下就可以了。 修改配置文件中的server选项，这时候就会有两个server。 server&#123; listen 8001; server_name localhost; root /usr/share/nginx/html/html8001; index index.html; &#125; 编在usr/share/nginx/html/html8001/目录下的index.html文件并查看结果。 最后在浏览器中分别访问地址和带端口的地址。看到的结果是不同的。 然后我们就可以在浏览器中访问http://112.74.164.244:8001了，当然你的IP跟这个肯定不一样，这个IP过几天就会过期的。 基于IP/域名的虚拟主机基于IP和基于端口的配置几乎一样，只是把server_name选项，配置成IP就可以了。 比如上面的配置，我们可以修改为： server&#123; listen 80; server_name 112.74.164.244; #或者直接写个域名也行 root /usr/share/nginx/html/html8001; index index.html; &#125; 反向代理我们现在的web模式基本的都是标准的CS结构，即Client端到Server端。那代理就是在Client端和Server端之间增加一个提供特定功能的服务器，这个服务器就是我们说的代理服务器。 正向代理：如果你觉的反向代理不好理解，那先来了解一下正向代理。我相信作为一个手速远超正常人的程序员来说，你一定用过翻墙工具（我这里说的不是物理梯子），它就是一个典型的正向代理工具。它会把我们不让访问的服务器的网页请求，代理到一个可以访问该网站的代理服务器上来，一般叫做proxy服务器，再转发给客户。简单来说就是你想访问目标服务器的权限，但是没有权限。这时候代理服务器有权限访问服务器，并且你有访问代理服务器的权限，这时候你就可以通过访问代理服务器，代理服务器访问真实服务器，把内容给你呈现出来。反向代理：反向代理跟代理正好相反（需要说明的是，现在基本所有的大型网站的页面都是用了反向代理），客户端发送的请求，想要访问server服务器上的内容。发送的内容被发送到代理服务器上，这个代理服务器再把请求发送到自己设置好的内部服务器上，而用户真实想获得的内容就在这些设置好的服务器上。这里proxy服务器代理的并不是客户端，而是服务器,即向外部客户端提供了一个统一的代理入口，客户端的请求都要先经过这个proxy服务器。具体访问那个服务器server是由Nginx来控制的。再简单点来讲，一般代理指代理的客户端，反向代理是代理的服务器。 反向代理的用途和好处 安全性：正向代理的客户端能够在隐藏自身信息的同时访问任意网站，这个给网络安全代理了极大的威胁。因此，我们必须把服务器保护起来，使用反向代理客户端用户只能通过外来网来访问代理服务器，并且用户并不知道自己访问的真实服务器是那一台，可以很好的提供安全保护。功能性：反向代理的主要用途是为多个服务器提供负债均衡、缓存等功能。负载均衡就是一个网站的内容被部署在若干服务器上，可以把这些机子看成一个集群，那Nginx可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上，从而实现服务器压力的平均分配，也叫负载均衡。最简单的反向代理 现在我们要访问 http://a.b.com 然后反向代理到b.com这个网站。我们直接到etc/nginx/con.d/8001.conf进行修改。 修改后的配置文件如下： server&#123; listen 80; server_name a.b.com; location / &#123; proxy_pass http://b.com; &#125; &#125; 一般我们反向代理的都是一个IP，但是我这里代理了一个域名也是可以的。其实这时候我们反向代理就算成功了，我们可以在浏览器中打开http://a.b.com来测试一下。（视频中有详细的演示） 其它反向代理指令 反向代理还有些常用的指令，我在这里给大家列出： proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。 proxy_connect_timeout:配置Nginx与后端代理服务器尝试建立连接的超时时间。 proxy_read_timeout : 配置Nginx向后端服务器组发出read请求后，等待相应的超时时间。 proxy_send_timeout：配置Nginx向后端服务器组发出write请求后，等待相应的超时时间。 proxy_redirect :用于修改后端服务器返回的响应头中的Location和Refresh。 Nginx 适配PC或Mobile$http_user_agent的使用： Nginx通过内置变量$http_user_agent，可以获取到请求客户端的userAgent，就可以用户目前处于移动端还是PC端，进而展示不同的页面给用户。 操作步骤如下： 在/usr/share/nginx/目录下新建两个文件夹，分别为：pc和mobile目录 cd /usr/share/nginx mkdir pc mkdir mobile 在pc和miblic目录下，新建两个index.html文件，文件里下面内容 &lt;h1&gt;I am pc!&lt;/h1&gt; &lt;h1&gt;I am mobile!&lt;/h1&gt; 进入etc/nginx/conf.d目录下，修改8001.conf文件，改为下面的形式: server&#123; listen 80; server_name nginx2.jspang.com; location / &#123; root /usr/share/nginx/pc; if ($http_user_agent ~* &#39;(Android|webOS|iPhone|iPod|BlackBerry)&#39;) &#123; root /usr/share/nginx/mobile; &#125; index index.html; &#125; &#125; Gzip压缩配置Gzip是网页的一种网页压缩技术，经过gzip压缩后，页面大小可以变为原来的30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快。gzip网页压缩的实现需要浏览器和服务器的支持。 从上图可以清楚的明白，gzip是需要服务器和浏览器同事支持的。当浏览器支持gzip压缩时，会在请求消息中包含Accept-Encoding:gzip,这样Nginx就会向浏览器发送听过gzip后的内容，同时在相应信息头中加入Content-Encoding:gzip，声明这是gzip后的内容，告知浏览器要先解压后才能解析输出。 gzip的配置项 Nginx提供了专门的gzip模块，并且模块中的指令非常丰富。 gzip : 该指令用于开启或 关闭gzip模块。 gzip_buffers : 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。 gzip_comp_level : gzip压缩比，压缩级别是1-9，1的压缩级别最低，9的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。 gzip_disable : 可以通过该指令对一些特定的User-Agent不使用压缩功能。 gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的Content-length中进行获取。 gzip_http_version：识别HTTP协议版本，其值可以是1.1.或1.0. gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容gzip压缩。 gzip_vary : 用于在响应消息头中添加Vary：Accept-Encoding,使代理服务器根据请求头中的Accept-Encoding识别是否启用gzip压缩。 gzip最简单的配置 http &#123; gzip on; gzip_types text/plain application/javascript text/css; &#125; 完整配置 gzip on; gzip_min_length 1k; gzip_buffers 4 16k; #gzip_http_version 1.0; gzip_comp_level 2; gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; gzip_vary off; gzip_disable &quot;MSIE [1-6]\\.&quot;; #IE6对Gzip不怎么友好 gzip on是启用gizp模块，下面的一行是用于在客户端访问网页时，对文本、JavaScript 和CSS文件进行压缩输出。 配置好后，我们就可以重启Nginx服务，让我们的gizp生效了。 如果你是windows操作系统，你可以按F12键打开开发者工具，单机当前的请求，在标签中选择Headers，查看HTTP响应头信息。你可以清楚的看见Content-Encoding为gzip类型。 服务器压力测试apach测试安装装个apach 然后直接可以运行 使用 ab -c 10 -n 100 https://www.baidu.com/ 注意最后必须有斜杠否则不认识 #服务器超过一千会自动禁止访问，为了防止攻击的，需要暂时关掉。 # vim /etc/sysctl.conf net.ipv4.tcp_syncookies = 0 # sysctl -p #然后就可以超过1000个并发测试了。 WebBench wget http://www.ha97.com/webbench-1.5.tar.gz tar -zxvf webbench-1.5.tar.gz cd webbench-1.5 make make install webbench -c 1000 -t 60 http://192.168.80.157/phpinfo.php webbench [option]... URL -f|--force Don&#39;t wait for reply from server. -r|--reload Send reload request - Pragma: no-cache. -t|--time &lt;sec&gt; 运行测试时间 Run benchmark for &lt;sec&gt; seconds. Default 30. -p|--proxy &lt;server:port&gt; Use proxy server for request. -c|--clients &lt;n&gt; 并发数 Run &lt;n&gt; HTTP clients at once. Default one. -9|--http09 Use HTTP/0.9 style requests. -1|--http10 Use HTTP/1.0 protocol. -2|--http11 Use HTTP/1.1 protocol. --get Use GET request method. --head Use HEAD request method. --options Use OPTIONS request method. --trace Use TRACE request method. -?|-h|--help This information. -V|--version Display program version. 结果说明 每秒钟响应请求数：24525 pages/min，每秒钟传输数据量20794612 bytes/sec. 并发1000运行60秒后产生的TCP连接数12000多个,已经显示有87个连接failed了，说明超负荷了。","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"系统","slug":"系统","permalink":"http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"开发","slug":"开发","permalink":"http://yoursite.com/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"mongodb","slug":"code/mongodb","date":"2019-09-11T03:06:00.000Z","updated":"2021-05-19T11:18:03.696Z","comments":true,"path":"2019/09/11/code/mongodb/","link":"","permalink":"http://yoursite.com/2019/09/11/code/mongodb/","excerpt":"","text":"安装下载安装包并解压选择下载包的时候 os 根据运行环境选择，如果是 centos 可选择 Ubuntu 版本的 linux 安装包，不同选项 OS 仅为针对不同版本的 linux。 //解压 tar -zxvf mongodb-linux-x86_64-3.0.6.tgz //全局变量 export PATH=安装路径/bin:$PATH // 创建data文件夹其中db存放数据，logs存放运行报错 - data - db - logs 启动与重启配置文件启动配置文件最好放在 mongodb 相关文件夹内配置文件详解 #!/bin/bash port=27017 dbpath=/data/db logpath=/data/logs/mongodb/mongodb.log logappend=true fork=true maxConns=5000 auth = false bind_ip = 0.0.0.0 启动配置 mongod.conf 文件并在启动 mongodb 时直接使用该文件启动，若修改端口号许加上 ip 跟端口号 127.0.0.1:8080linux 命令mongod –config /data/mongod.confwindows 命令mongod -f /data/mongod.conf 重启ps aux |grep mongodb查看进程号kill -2 进程号然后运行启动命令 用户操作 //全局用户需进入admin库内，某个库的用户需进入某个库内 use admin //新增系统管理员用户 db.createUser( &#123; user: &quot;root&quot;, pwd: &quot;123456&quot;, roles: [ &#123; role: &quot;root&quot;, db: &quot;admin&quot; &#125; ] &#125; ) //鉴权用户 db.auth(&quot;root&quot;,&quot;123456&quot;) //查看当前库中的所有用户 show users 角色分类详解内建角色：数据库用户角色：read、readWrite；数据库管理角色：dbAdmin、dbOwner、userAdmin；集群管理角色： clusterAdmin、clusterManager、clusterMonitor、hostManager；备份恢复角色： backup、restore；所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase超级用户角色： root； 这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase）内部角色： __system； 角色说明：Read： 允许用户读取指定数据库readWrite： 允许用户读写指定数据库dbAdmin： 允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问 system.profileuserAdmin： 允许用户向 system.users 集合写入，可以找指定数据库里创建、删除和管理用户dbOwner： 允许在当前 DB 中执行任意操作readAnyDatabase： 赋予用户所有数据库的读权限，只在 admin 数据库中可用readWriteAnyDatabase： 赋予用户所有数据库的读写权限，只在 admin 数据库中可用userAdminAnyDatabase：赋予用户所有数据库管理 User 的权限，只在 admin 数据库中可用dbAdminAnyDatabase： 赋予管理所有数据库的权限，只在 admin 数据库中可用root： 超级账号，超级权限，只在 admin 数据库中可用。 集群管理角色：clusterAdmin： 赋予管理集群的最高权限，只在 admin 数据库中可用clusterManager： 赋予管理和监控集群的权限clusterMonitor： 赋予监控集群的权限，对监控工具具有 readonly 的权限hostManager： 赋予管理 Server 索引db.集合.ensureIndex({username:1})简历索引可以极大地加快查找速度，但是会对系统与硬盘有所影响。 注意：• 数据不超万条时，不需要使用索引。性能的提升并不明显，而大大增加了内存和硬盘的消耗。• 查询数据超过表数据量 30%时，不要使用索引字段查询。实际证明会比不使用索引更慢，因为它大量检索了索引表和我们原表。• 数字索引，要比字符串索引快的多，在百万级甚至千万级数据量面前，使用数字索引是个明确的选择。• 把你经常查询的数据做成一个内嵌数据（对象型的数据），然后集体进行索引。 复合索引复合索引就是两条以上的索引。MongoDB 的复合查询是按照我们的索引顺序进行查询的。那个在前面则先使用那个索引的值开始查。新增其他的索引并且查看是否添加成功，查找时直接匹配两个值即可。指定索引查询（hint）指定首先使用那个索引查找，因为数字的索引要比字符串的索引快，所以通常会指定数字索引。1 为 truedb.randomInfo.find({ “userName”:”河绍世国”,age:39}).hint({age:1}) 全文索引这节我们先建立一个集合（collections）-info，然后插入一小段文章，作用就是为建立全文索引提供数据，当然我们不再建立百万级数据，我们只是看一下效果。 • db.info.insert(&#123;contextInfo:&quot;I am a programmer, I love life, love family. Every day after work, I write a diary.&quot;&#125;) • db.info.insert(&#123;contextInfo:&quot;I am a programmer, I love PlayGame, love drink. Every day after work, I playGame and drink.&quot;&#125; 建立全文索引• db.info.ensureIndex(&#123;contextInfo:&#39;text&#39;&#125;) 需要注意的是这里使用 text 关键词来代表全文索引，我们在这里就不建立数据模型了。例：db.info.find({$text:{$search:”PlayGame”}})查找多个词全文索引是支持多个次查找的，比如我们希望查找数据中有 programmer，family，diary，drink 的数据（这是或的关系），所以两条数据都会出现。 • db.info.find(&#123;$text:&#123;$search:&quot;programmer family diary drink&quot;&#125;&#125;) 如果我们这时候希望不查找出来有 drink 这个单词的记录，我们可以使用“-”减号来取消。 • dbd .info.find(&#123;$text:&#123;$search:&quot;programmer family diary -drink&quot;&#125;&#125;) 转义符：全文搜索中是支持转义符的，比如我们想搜索的是两个词（love PlayGame 和 drink），这时候需要使用\\斜杠来转意。多个单词的时候#### 使用db.info.find({$text:{$search:”&quot;love drink&quot;“}}) 总结全文索引在工作还是经常使用的，比如博客文章的搜索，长文件的关键词搜索，这些都需要使用全文索引来进行。","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"疑难杂症","slug":"code/other","date":"2019-08-26T06:18:00.000Z","updated":"2021-05-19T11:18:03.697Z","comments":true,"path":"2019/08/26/code/other/","link":"","permalink":"http://yoursite.com/2019/08/26/code/other/","excerpt":"","text":"微信内置浏览器微信须知安卓： 无法自动播放视频，无法自动播放音乐，需要点击后才可播放。 视频全屏模式的退出需要display即可。 华为全屏模式顶部有一段空白。IOS： 缓存比较顽固，需要使劲刷新。 更换路径后不自动播放就加个autoplay就好了。长按二维码识别的功能监听可用touchstart监听开始自行判断是否有touchend判断是否是长按。 刷新页面无效 function refresh() &#123; var timestamp = new Date().getTime(); var url = decodeURI(window.location.href); if (url.indexOf(&#39;?&#39;) &lt; 0) &#123; url = url + &quot;?_refresh_time_=&quot; + timestamp; window.location.href = url; return; &#125; var t_pos0 = url.indexOf(&#39;_refresh_time_&#39;); var t_after_str = &#39;&#39;; var t_before_str = url; if (t_pos0 &gt;= 0) &#123; t_before_str = url.substring(0, t_pos0); var t_pos1 = url.indexOf(&#39;&amp;&#39;, t_pos0 + 1); if (t_pos1 &gt;= 0) &#123; t_after_str = url.substr(t_pos1); &#125; &#125; url = t_before_str + &#39;&amp;_refresh_time_=&#39; + timestamp; url += t_after_str; window.location.href = url; &#125; 多媒体兼容所有的播放媒体都不要放在组件内，重新render的时候会刷新造成卡顿黑屏或停止播放等一堆问题。 可以覆盖在video标签上做交互视频 playsinline=&quot;true&quot; webkit-playsinline=&quot;true&quot; x5-video-player-type=&quot;h5&quot; x5-video-player-fullscreen=&quot;true&quot; x5-video-orientation=&quot;portrait&quot; audio自动播放 // 引入wx jssdk才可兼容微信 // &lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.0.0.js&quot;&gt;&lt;/script&gt; window.audioBg = document.getElementById(&quot;bgAudio&quot;); function forceSafariPlayAudio() &#123; audioBg.load(); audioBg.play(); // iOS 7/8 仅需要 play 一下 &#125; // 触摸屏幕 document.addEventListener(&quot;touchend&quot;, forceSafariPlayAudio, false); audioBg.addEventListener( &quot;play&quot;, function() &#123; document.removeEventListener(&quot;touchend&quot;, forceSafariPlayAudio, false); &#125;, false ); if ( typeof WeixinJSBridge == &quot;object&quot; &amp;&amp; typeof WeixinJSBridge.invoke == &quot;function&quot; ) &#123; forceSafariPlayAudio(); &#125; // 微信打开 document.addEventListener( &quot;WeixinJSBridgeReady&quot;, function() &#123; forceSafariPlayAudio(); &#125;, false ); video自动播放 // 引入wx jssdk才可兼容微信 // &lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.0.0.js&quot;&gt;&lt;/script&gt; // 若浏览器支持自动播放则可直接播放若不支持则需要跳转至引导页 let videoType = false; // 微信环境 if (vUtil.UA.wx) &#123;//vUtil需要引入该包 document.addEventListener(&quot;WeixinJSBridgeReady&quot;, myVideo.play, false); &#125; myVideo.addEventListener( &quot;canplaythrough&quot;, function(e) &#123; console.log(&quot;加载完毕&quot;); if (!videoType) &#123; try &#123; const playPromise = myVideo.play(); // 调用失败的解决方案 if (playPromise !== undefined) &#123; playPromise.catch(() =&gt; &#123; console.log(&quot;playback prevented&quot;); //跳转至引导页 &#125;); &#125; &#125; catch (error) &#123; console.log(error); //跳转至引导页 &#125; &#125; &#125;, false ); // 播放时间 判断是否成功自动播放 myVideo.addEventListener( &quot;timeupdate&quot;, function(e) &#123; // 查看播放时间 只开一下是0.001 if (myVideo.currentTime &gt; 0.01 &amp;&amp; !videoType) &#123; videoType = true; &#125; &#125;, false ); //监听播放暂停 myVideo.addEventListener( &quot;pause&quot;, function() &#123; console.log(&quot;pause&quot;); // 若一次都没播放则展示打开按钮 if (!videoType) &#123; //跳转至引导页 &#125; &#125;, false ); media API audio与video的部分属性事件都一致。 &lt;!-- video 不支持 IE8及以下版本浏览器，支持三种视频格式：MP4，WebM 和 Ogg --&gt; &lt;video src=&quot;test.mp4&quot; controls width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/video&gt; &lt;!-- 禁止下载 --&gt; &lt;video src=&quot;test.mp4&quot; controls controlslist=&quot;nodownload&quot; width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/video&gt; &lt;!-- 禁止下载，禁止全屏 --&gt; &lt;video src=&quot;test.mp4&quot; controls controlslist=&quot;nodownload nofullscreen&quot; width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/video&gt; &lt;!-- 自动播放 （不同浏览器的表现不一样） --&gt; &lt;video src=&quot;test.mp4&quot; controls autoplay width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/video&gt; &lt;!-- 默认静音播放（可手动点开继续播放） --&gt; &lt;video src=&quot;test.mp4&quot; controls muted width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/video&gt; &lt;!-- 循环播放 --&gt; &lt;video src=&quot;test.mp4&quot; controls loop width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/video&gt; &lt;!-- 预加载 --&gt; &lt;video src=&quot;test.mp4&quot; controls preload width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/video&gt; &lt;!-- 贴图 --&gt; &lt;video src=&quot;test.mp4&quot; poster=&quot;poster.jpg&quot; controls width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/video&gt; let video = documnet.getElementById(&#39;video&#39;); //检测该浏览器是否支持某种类型视频，例如MP4 let ability = video.canPlayType(&#39;video/mp4&#39;);//返回&quot;probably&quot;,&quot;maybe&quot;,&quot;&quot; //播放 video.play(); //暂停 video.pause() //加载，一般用于更改源，重新加载视频 video.src=&#39;other.mp4&#39;; video.load(); 属性： currentSrc 当前视频地址 currentTime 视频已播放时间 videoWidth 视频本身的宽度 videoHeight 视频本身的高度 duration 视频长度，流返回无限 ended 是否播放结束 error 媒体错误（null:正常） paused 是否停止 muted 是否静音 seeking 是否在seeking volume 音量 取值范围：0 到 1，0 是静音，0.5 是一半的音量，1 是最大音量（默认值） height 播放框的高度 width 播放框的宽度 以上都是官方文档里的一般属性，下面将补充一些属性 startTime 开始时间，默认为0 defaultPlaybackRate 默认回放速度 playbackRate 当前播放速度 var video = document.getElementById(&#39;video&#39;) // 1、loadstart：视频查找。当浏览器开始寻找指定的音频/视频时触发，也就是当加载过程开始时 video.addEventListener(&#39;loadstart&#39;, function(e) &#123; console.log(&#39;提示视频的元数据已加载&#39;) console.log(e) console.log(video.duration) // NaN &#125;) loadstart 客户端开始请求数据 progress 客户端正在请求数据 suspend 延迟下载 abort 客户端主动终止下载（不是因为错误引起） error 请求数据时遇到错误 stalled 当浏览器尝试获取媒体数据，但数据不可用时 play play()和autoplay开始播放时触发 pause pause()触发 loadedmetadata 成功获取资源长度 loadeddata waiting 视频加载等待。当视频由于需要缓冲下一帧而停止，等待时触发 playing 开始回放 canplay 可以播放，但中途可能因为加载而暂停 canplaythrough 可流畅播放。当浏览器预计能够在不停下来进行缓冲的情况下持续播放指定的音频/视频时触发 seeking 查找开始。当用户开始移动/跳跃到音频/视频中新的位置时触发 seeked 查找结束。当用户已经移动/跳跃到视频中新的位置时触发 timeupdate 播放时间改变 ended 播放结束 ratechange 当视频的播放速度已更改时 durationchange 资源长度改变 volumechange 音量改变 x5videoenterfullscreen 进入全屏模式 x5videoexitfullscreen 退出全屏模式 3D全景图（pannellum）介绍多种方案介绍国外的框架pannellum，实现简单。krpano这个框架最好但是收费，一年一百多欧元相当于一千左右人民币了。pass…优秀操作手册 注意 图片可为4096宽的，注意图片跨域问题。 热点图标不可更改不可替换。 热点坐标拾取的时候设置hotSpotDebug: true，即可在控制台查看坐标信息。 热点内容不但可以是文字还可以是图片或者视频 开发首先下载对应css与js到本地引入项目。 #panorama &#123; position: fixed; left: 0; top: 0; width: 100%; height: 100%; &#125; &lt;div id=&quot;panorama&quot;&gt;&lt;/div&gt; &lt;script&gt; pannellum.viewer(&quot;panorama&quot;, &#123; type: &quot;equirectangular&quot;, panorama: &quot;./111111.jpg&quot;, autoLoad: true, // title: &quot;这是一段文字&quot;, // preview: &quot;&quot;, //预览图 hotSpots: [ &#123; pitch: -20.534419348137646, yaw: -12.163622115720447, type: &quot;info&quot;, text: &quot;这是一段文字&quot; &#125; ], // hotSpotDebug: true,//获取热点坐标的时候开启可以查看坐标 error: function(data) &#123; console.log(data); &#125; &#125;); &lt;/script&gt; 自动化部署环境要求服务器需要node环境 配置项目ssh在linux系统中的 /root/.ssh/ 中复制id_rsa.pub文件中的内容去添加项目ssh 服务端新建koa2项目配置一个简单的服务端项目，在接口被调用的时候运行命令。 const Koa = require(&quot;koa2&quot;), Router = require(&quot;koa-router&quot;), process = require(&quot;child_process&quot;), app = new Koa(), router = new Router(&#123;&#125;); router.post(&quot;/pushCode&quot;, async (ctx, next) =&gt; &#123; //直接调用命令 const error = await new Promise((resolve, reject) =&gt; &#123; //这个/home/my_space_formal是demo目录，我只需要pull代码即可，可以根据情况自己设置命令 process.exec(&quot;cd /home/my_project &amp;&amp;git pull origin master&quot;, function(error) &#123; resolve(error); &#125;); &#125;); if (error !== null) &#123; ctx.body = &quot;exec error: &quot; + error; &#125; else &#123; ctx.body = &quot;服务端发起自执行&quot;; &#125; &#125;); app.use(router.routes()); app.listen(888, () =&gt; &#123; console.log(&quot;serve is start&quot;); &#125;); &#123; &quot;dependencies&quot;: &#123; &quot;koa-router&quot;: &quot;^7.4.0&quot;, &quot;koa2&quot;: &quot;^2.0.0-alpha.7&quot; &#125; &#125; 配置好项目后将项目拉至服务器合适的地方，安装相关安装包 运行项目 安装forever.js 运行npm install forever -g 到上述项目文件夹中运行 forever start index.js 即可让node服务在后台一直运行。 forever stop app.js #关闭应用 forever restartall #重启所有应用 forever list 显示所有运行的服务 然后代码往github一推服务端就直接自动执行命令了解决git clone速度太慢查询CDN查询以下域名最快的cdn github.com assets-cdn.github.com github.global.ssl.fastly.net 修改hosts文件路径：C:\\Windows\\System32\\drivers\\etc 192.30.253.113 github.com 185.199.108.153 assets-cdn.github.com 151.101.185.194 github.global.ssl.fastly.net 刷新DNS缓存window：cmd中敲入 ipconfig /flushdns 使用https下载火箭般的速度，怎一个爽字得了！ReactReact不支持转义部分es6只能增加配置转义或者增加该api","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"egg+mongodb开发后台","slug":"code/egg_serve","date":"2019-08-16T09:13:00.000Z","updated":"2021-05-19T11:18:03.695Z","comments":true,"path":"2019/08/16/code/egg_serve/","link":"","permalink":"http://yoursite.com/2019/08/16/code/egg_serve/","excerpt":"","text":"注意 mongoose中根据id查的时候不用转ObjectId 环境开发须知优秀范例全局安装egg脚手架egg-initegg-init projectName –type simple安装相关插件yarn add egg-validate egg-mongoose 项目解析相关目录官方解释目录作用 //app/extend/xxx.js下的各this指向 application.js —— this指向：app对象 调用：this.app context.js —— this指向：ctx对象 调用：this.ctx request.js —— this指向：ctx.request对象 调用：this.ctx.request response.js —— this指向：ctx.response对象 调用：this.ctx.response helper.js —— this指向：ctx.helper对象 调用：this.ctx.helper 开发须知 model文件中的返回的值 return mongoose.model(“User”, UserSchema, “user”);第一个为调用名称，第二位模版，第三为要操作的集合。调试配置vscode中launch.js文件 &#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Launch Egg&quot;, &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;, &quot;runtimeExecutable&quot;: &quot;npm&quot;, &quot;windows&quot;: &#123; &quot;runtimeExecutable&quot;: &quot;npm.cmd&quot; &#125;, &quot;runtimeArgs&quot;: [ &quot;run&quot;, &quot;debug&quot; ], &quot;console&quot;: &quot;integratedTerminal&quot;, &quot;protocol&quot;: &quot;auto&quot;, &quot;restart&quot;: true, &quot;port&quot;: 9999 &#125; ] &#125; 连接数据库mongodbegg配置连接使用egg-mongoose连接mongodb //config/plugin.js中增加 exports.mongoose = &#123; enable: true, package: &#39;egg-mongoose&#39;, &#125;; //config/config.default.js中增加 //这段一定写在module.exports = appInfo =&gt; &#123;里面，妈的官网是错的让我捯饬半天。 config.mongoose = &#123; url: &quot;mongodb://127.0.0.1/mypwd&quot;, //你的数据库地址，端口号不同就直接加载ip后面，没改则不用加，必须有这个库才能连接成功 options: &#123; user: &quot;root&quot;,//账号密码 pass: &quot;root&quot; &#125; &#125;; // 关闭安全协议可以在postman中测试，不关只能在浏览器测试 config.security = &#123; csrf: &#123; enable: false, ignoreJSON: true // 默认为 false，当设置为 true 时，将会放过所有 content-type 为 `application/json` 的请求 &#125; // domainWhiteList: [&quot;http://127.0.0.1:8080&quot;] &#125;; mongodb配置 #!/bin/bash port=27017 dbpath=/data/db logpath=/data/logs/mongodb/mongodb.log logappend=true fork=true//后台运行，window中该属性不可用 maxConns=5000 auth = true//是否开启用户权限验证 bind_ip = 0.0.0.0 传参校验使用 egg-validate实现校验 // config/plugin.js exports.validate = &#123; enable: true, package: &#39;egg-validate&#39;, &#125;; // controller中应用 const rule = &#123; id: &#123; type: &quot;string&quot;, required: true, message: &quot;必填项&quot; &#125; &#125;; await ctx.validate(rule, params); //错误的话会返回错误信息但是不能手动设置 扩展方法返回值 //app/extend/context.js &quot;use strict&quot;; module.exports = &#123; returnBody(status, data = null) &#123; this.status = 200; this.body = &#123; status, data, statusTxt:status==200?&#39;success&#39;:&#39;error&#39; &#125;; &#125; &#125;; //调用 ctx.returnBody(100, &quot;传参有误&quot;);","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"后台","slug":"后台","permalink":"http://yoursite.com/tags/%E5%90%8E%E5%8F%B0/"}]},{"title":"开发常用","slug":"code/often_use","date":"2019-08-14T03:53:00.000Z","updated":"2021-05-19T11:18:03.697Z","comments":true,"path":"2019/08/14/code/often_use/","link":"","permalink":"http://yoursite.com/2019/08/14/code/often_use/","excerpt":"","text":"Git.gitignore规则不生效.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。 解决方法就是先把本地缓存删除（改变成未track状态），然后再提交: git rm -r --cached . git add . git commit -m &#39;update .gitignore&#39; 基础样式.dis_n &#123; display: none; &#125; .dis_b &#123; display: block; &#125; .w100 &#123; width: 100%; &#125; .h100 &#123; height: 100%; &#125; .wh100 &#123; width: 100%; height: 100%; &#125; .ov &#123; overflow: hidden; &#125; .txo &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; /*不换行*/ &#125; /* flex */ .dis_f &#123; display: flex; display: -webkit-flex; &#125; .jus_bt &#123; justify-content: space-between; -webkit-justify-content: space-between; &#125; .jus_ct &#123; justify-content: center; -webkit-justify-content: center; &#125; .jus_rt &#123; justify-content: flex-end; -webkit-justify-content: flex-end; &#125; .jus_cen &#123; justify-content: space-around; -webkit-justify-content: space-around; &#125; .ali_ct &#123; align-items: center; -webkit-align-items: center; &#125; .ali_end &#123; align-items: flex-end; -webkit-align-items: flex-end; &#125; .ali_top &#123; align-items: flex-start; -webkit-align-items: flex-start; &#125; .ali_h100 &#123; align-items: stretch; &#125; .fl1 &#123; flex: 1; &#125; /* 溢出向下排列 */ .flw_w &#123; flex-wrap: wrap; &#125; /* 从上往下 */ .fle_t &#123; flex-direction: column; &#125; .fle_f &#123; flex-direction: column-reverse; &#125; /* 不缩放 */ .fle_no &#123; flex-shrink: 0; &#125; /* 定位 */ .por &#123; position: relative; &#125; .poa &#123; position: absolute; &#125; .tbcen &#123; top: 50%; transform: translateY(-50%); &#125; .lrcen &#123; left: 50%; transform: translateX(-50%); &#125; .cen &#123; left: 50%; top: 50%; transform: translate(-50%, -50%); &#125; /* 蒙版 */ .b_box &#123; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); position: absolute; left: 0; top: 0; &#125; /* 固定宽高 */ .scroll_class &#123; top: 0px; left: 0px; width: 100%; height: 100%; overflow: hidden; position: fixed; z-index: 1; &#125; /* 颜色 */ .wht &#123; background: #fff; &#125; /* 楼层 */ .p2 &#123; padding: 0 20rpx; &#125; .borB &#123; border-bottom: 1px solid #e6e6e6; &#125; .borB:last-of-type &#123; border: none; &#125; .borB20 &#123; border-bottom: 20rpx solid #f5f5f5; &#125; .wht_box &#123; width: 100%; height: 100%; position: fixed; left: 0; top: 0; z-index: 1; overflow: auto; &#125; .noscroll &#123; top: 0px; left: 0px; width: 100%; height: 100%; overflow: hidden; position: fixed; z-index: 0; &#125; 微信小程序基础样式// ::-webkit-scrollbar &#123; // // width: 0; // // height: 0; // // color: transparent; // width: 6px; // background-color: #f5f5f5; // &#125;//滚动条 ::-webkit-scrollbar-thumb &#123;//滚动条背景 background-color: #aaa; &#125; /* 怪异模式 */ .bos &#123; box-sizing: content-box; &#125; .navigator-hover &#123; background-color: transparent; opacity: 0.5; &#125; button &#123; padding: 0; margin: 0; &#125; .button-hover &#123; background-color: transparent; opacity: 0.5; &#125; button::after &#123; display: none; &#125; page,view,text,image,icon,textarea,switch,input,scroll-view &#123; // font-family: &quot;PingFang SC&quot;, -apple-system, &quot;Helvetica Neue&quot;, Helvetica, STHeiTi, sans-serif; box-sizing: border-box; line-height: 100%; padding: 0; margin: 0; flex-shrink: 0; &#125; h5 基础样式 // 引入字体 // @font-face &#123; // font-family: &quot;NotoSansHans-Bold&quot;; // src: url(&quot;../font/NotoSansHans-Bold.otf&quot;); // font-family: &quot;NotoSansHans-Regular&quot;; // src: url(&quot;../font/NotoSansHans-Regular.otf&quot;); // font-weight: normal; // font-style: normal; // &#125; a,article,aside,audio,::before,::after,b,blockquote,body,canvas,caption,dd,details,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,label,legend,li,menu,nav,object,ol,output,p,s,section,small,span,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video &#123; margin: 0; padding: 0; border: 0; -webkit-box-sizing: border-box; -webkit-tap-highlight: transparent; /*清除点击默认的高亮效果*/ &#125; ol,ul,li &#123; list-style: none; &#125; table &#123; border-collapse: collapse; /*表格的边线重叠*/ border-spacing: 0; &#125; input,textarea &#123; border: 0 none; resize: none; /*调整尺寸*/ /*outline:none;*/ /*清除表单默认的蓝色边框效果*/ -webkit-appearance: none; /* 针对表单的默认的样式进行清除 比如立体效果*/ &#125; :focus &#123; outline: none; &#125; img &#123; display: block; -webkit-touch-callout: none; /*当你触摸并按住触摸目标时候，禁止或显示系统默认菜单 */ &#125; a,a:link,a:visited &#123; text-decoration: none; color: #343434; -webkit-touch-callout: none; &#125; .clearfix:after &#123; content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden; &#125; .fl &#123; float: left; &#125; .fr &#123; float: right; &#125; html &#123; -webkit-text-size-adjust: none; /*不调整（拉伸）字大小*/ &#125; body &#123; font-family: &quot;NotoSansHans-Bold&quot;, &quot;microsoft yahei&quot;, &quot;\\534E\\6587\\7EC6\\9ED1&quot;, Verdana, Arial, Helvetica, sans-serif; -webkit-user-select: none; /*禁止选中内容*/ &#125; /*微软雅黑 华文细黑 最后一个字体：ios系统默认 */ 常用正则 export default (type, data) =&gt; &#123; const checkList = &#123; name: /^[\\u4e00-\\u9fa5]&#123;2,8&#125;$/gi, phone: /^[1][1-9][0-9]&#123;9&#125;$/, iCard: /\\d&#123;17&#125;[\\d|x]|\\d&#123;15&#125;/, email: /^([a-zA-Z0-9]+[_|\\_|\\.]?)*[a-zA-Z0-9]+@([a-zA-Z0-9]+[_|\\_|\\.]?)*[a-zA-Z0-9]+\\.[a-zA-Z]&#123;2,3&#125;$/, &#125;; return !checkList[type].test(data); &#125;; 常用方法export const formatDate = data =&gt; &#123; let date; if (!(&quot;time&quot; in data)) &#123; date = new Date(); &#125; else &#123; date = new Date(Number(data.time)); &#125; var o = &#123; &quot;M+&quot;: date.getMonth() + 1, //月份 &quot;d+&quot;: date.getDate(), //日 &quot;h+&quot;: date.getHours(), //小时 &quot;H+&quot;: date.getHours(), //小时 &quot;m+&quot;: date.getMinutes(), //分 &quot;s+&quot;: date.getSeconds(), //秒 &quot;q+&quot;: Math.floor((date.getMonth() + 3) / 3), //季度 S: date.getMilliseconds() //毫秒 &#125;; var week = &#123; &quot;0&quot;: &quot;/u65e5&quot;, &quot;1&quot;: &quot;/u4e00&quot;, &quot;2&quot;: &quot;/u4e8c&quot;, &quot;3&quot;: &quot;/u4e09&quot;, &quot;4&quot;: &quot;/u56db&quot;, &quot;5&quot;: &quot;/u4e94&quot;, &quot;6&quot;: &quot;/u516d&quot; &#125;; // 返回的时间 let backTime = data.type; if (/(y+)/.test(backTime)) &#123; backTime = backTime.replace( RegExp.$1, (date.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length) ); &#125; if (/(E+)/.test(backTime)) &#123; backTime = backTime.replace( RegExp.$1, (RegExp.$1.length &gt; 1 ? RegExp.$1.length &gt; 2 ? &quot;/u661f/u671f&quot; : &quot;/u5468&quot; : &quot;&quot;) + week[date.getDay() + &quot;&quot;] ); &#125; for (var k in o) &#123; if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(backTime)) &#123; backTime = backTime.replace( RegExp.$1, RegExp.$1.length == 1 ? o[k] : (&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length) ); &#125; &#125; return backTime; &#125; 分析打包后文件占比yarn add source-map-explorer -D增加脚本&quot;analyze&quot;: &quot;source-map-explorer &#39;build/static/js/*.js&#39;&quot;,运行该命令后可以分析打包文件进而进行编辑修改。","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"Taro.js","slug":"code/taro","date":"2019-07-16T02:25:00.000Z","updated":"2021-05-19T11:18:03.698Z","comments":true,"path":"2019/07/16/code/taro/","link":"","permalink":"http://yoursite.com/2019/07/16/code/taro/","excerpt":"","text":"初始化项目创建项目使用 npm 安装 CLI npm install -g @tarojs/cli OR 使用 yarn 安装 CLI yarn global add @tarojs/cli 安装指定版本taro yarn global add @tarojs/cli@1.3.34 更新项目到指定版本 taro update project 2.0.3 更新TaroCLi到指定版本 taro update self 2.0.3 npx直接安装最新版本项目（不建议，会和本地的不兼容） npx @tarojs/cli init myApp 值得一提的是，如果安装过程出现sass相关的安装错误，请在安装mirror-config-china后重试。 npm install -g mirror-config-china 如果出现使用async方法报错Function则需要安装低版本regenerator-runtime yarn add regenerator-runtime@0.11.1 注意 1.小程序所有配置文件都在app.jsx 2.render中可以使用解构赋值。 3.小程序开发会经常报错无法运行，如果找不到文件需要重新退出再打开项目，如果页面展示不正常需要重新打包并退出小程序开发工具重新运行。 4.reducer可以合并在一起，没必要那么分散。 5.所有小程序中的组件属性如果带-的都转为驼峰命名。 6.taro中部分组件生命周期与小程序一致，部分没有需要使用小程序自带的方法。 7.async报错官方文档 修改配置修改actions文件夹内counter.ts为index.tsTaro2.0不生成sitemap.json文件,防止小程序报错没有收录文件所以我们自己在根目录生成。 &#123; &quot;rules&quot;:[&#123; &quot;action&quot;: &quot;allow&quot;, &quot;page&quot;: &quot;*&quot; &#125;] &#125; 在config文件夹中的index.js文件中设置别名，并增加sitemap.json自动复制 //最顶部引入 const path = require(&#39;path&#39;); //找到outputRoot在他下面添加路径别名，并copy过去文件 outputRoot: &quot;dist&quot;, copy: &#123; patterns: [ &#123; from: &quot;sitemap.json&quot;, to: `dist/sitemap.json` &#125; ] &#125;, alias: &#123; &quot;@&quot;: path.resolve(__dirname, &quot;..&quot;, &quot;src/&quot;), &quot;@img&quot;: path.resolve(__dirname, &quot;..&quot;, &quot;src/assets/img&quot;), &quot;@api&quot;: path.resolve(__dirname, &quot;..&quot;, &quot;src/utils/api&quot;), &#125;, 修改根目录tsconfig.json文件，让VScode认识我们设置的别名。 // 在compilerOptions选项中增加 &quot;paths&quot;:&#123; &quot;@/*&quot;: [&quot;src/*&quot;], &quot;@img/*&quot;:[&quot;src/assets/img/*&quot;], &quot;@api*&quot;:[&quot;src/utils/api/index&quot;], &#125; // 在对象根部exclude的上面增加引入规则 &quot;include&quot;: [&quot;src/**/*&quot;], 自动化生成页面使用Node命令，一行命令生成tsx文件与scss文件，并初始化内容。根目录新建GenerateTemplate.js文件 const fs = require(&quot;fs&quot;); const dirName = titleCase(process.argv[2]); if (!dirName) &#123; console.error(&quot;页面或模块名称不能为空&quot;); process.exit(0); &#125; const genType = (process.argv[3]).toLowerCase(); if (genType !== &quot;p&quot; &amp;&amp; genType !== &quot;c&quot;) &#123; console.error(&quot;生成类型不能为空&quot;); process.exit(0); &#125; // 页面文件模版 const pageTpl = ` import Taro, &#123; Component, Config &#125; from &#39;@tarojs/taro&#39; import &#123; View &#125; from &#39;@tarojs/components&#39; import &#123; ComponentClass &#125; from &#39;react&#39; import &#39;./index.scss&#39; import &#123; connect &#125; from &#39;@tarojs/redux&#39; type PageStateProps = &#123; counter: any, dispatch: Function, &#125; type PageDispatchProps = &#123; &#125; type PageOwnProps = &#123; &#125; type PageState = &#123; &#125; type IProps = PageStateProps &amp; PageDispatchProps &amp; PageOwnProps interface $&#123;dirName&#125; &#123; props: IProps; // state: PageState &#125; @connect((&#123; counter &#125;) =&gt; (&#123; counter &#125;)) class $&#123;dirName&#125; extends Component &#123; config: Config = &#123; navigationBarTitleText: &#39;$&#123;dirName&#125;页面&#39; &#125; state:any = &#123; &#125; componentDidMount() &#123; &#125; render() &#123; const &#123; &#125; = this.state; const &#123; &#125; = this.props.counter; return ( &lt;View&gt; $&#123;dirName&#125; &lt;/View &gt; ) &#125; &#125; export default $&#123;dirName&#125; as ComponentClass&lt;PageOwnProps, PageState&gt; `; // 组件文件模版 const compTpl = ` import Taro, &#123; Component, Config, ComponentOptions &#125; from &#39;@tarojs/taro&#39; import &#123; View &#125; from &#39;@tarojs/components&#39; import &#123; ComponentClass &#125; from &#39;react&#39; import &#123; connect &#125; from &#39;@tarojs/redux&#39; import &#39;./index.scss&#39; type PageStateProps = &#123; counter: any, dispatch: Function, &#125; type PageDispatchProps = &#123; &#125; type PageOwnProps = &#123; &#125; type PageState = &#123; &#125; type IProps = PageStateProps &amp; PageDispatchProps &amp; PageOwnProps interface $&#123;dirName&#125; &#123; props: IProps; // state: PageState &#125; const defaultProps = &#123; &#125; @connect((&#123; counter &#125;) =&gt; (&#123; counter &#125;)) class $&#123;dirName&#125; extends Component &#123; static options: ComponentOptions = &#123; &quot;addGlobalClass&quot;: true &#125; state:any = &#123; &#125; componentDidMount() &#123; &#125; render() &#123; const &#123; &#125; = this.state; const &#123; &#125; = this.props; const &#123; &#125; = this.props.counter; return ( &lt;View&gt; $&#123;dirName&#125; &lt;/View &gt; ) &#125; &#125; const $&#123;dirName&#125;Class = $&#123;dirName&#125; as ComponentClass&lt;PageOwnProps, PageState&gt;; $&#123;dirName&#125;Class.defaultProps = defaultProps; export default $&#123;dirName&#125;Class `; let parentDir = process.argv[4]; let boo = false; if (parentDir) &#123; parentDir = titleCase(parentDir); boo = true; &#125; // 创建页面 if (genType === &quot;p&quot;) &#123; if (boo) &#123; if (!fs.existsSync(`./src/pages/$&#123;parentDir&#125;`)) &#123; fs.mkdirSync(`./src/pages/$&#123;parentDir&#125;`); &#125; fs.mkdirSync(`./src/pages/$&#123;parentDir&#125;/$&#123;dirName&#125;`); process.chdir(`./src/pages/$&#123;parentDir&#125;/$&#123;dirName&#125;`); &#125; else &#123; fs.mkdirSync(`./src/pages/$&#123;dirName&#125;`); process.chdir(`./src/pages/$&#123;dirName&#125;`); &#125; fs.writeFileSync(&#39;Index.tsx&#39;, pageTpl); fs.writeFileSync(&#39;Index.scss&#39;, &#39;&#39;); &#125; // 创建组件 if (genType === &quot;c&quot;) &#123; if (boo) &#123; if (!fs.existsSync(`./src/Components/$&#123;parentDir&#125;`)) &#123; fs.mkdirSync(`./src/Components/$&#123;parentDir&#125;`); &#125; fs.mkdirSync(`./src/Components/$&#123;parentDir&#125;/$&#123;dirName&#125;`); process.chdir(`./src/Components/$&#123;parentDir&#125;/$&#123;dirName&#125;`); &#125; else &#123; fs.mkdirSync(`./src/Components/$&#123;dirName&#125;`); process.chdir(`./src/Components/$&#123;dirName&#125;`); &#125; fs.writeFileSync(&#39;Index.tsx&#39;, compTpl); fs.writeFileSync(&#39;Index.scss&#39;, &#39;&#39;); &#125; console.log(`模版$&#123;dirName&#125;已创建,请手动至app.tsx文件添加页面路径`); function titleCase(str) &#123; const first = str[0]; const string = first.toUpperCase() + str.substr(1); return string; &#125; function insertStr(soure, newStr, start) &#123; return soure.slice(0, start) + newStr + soure.slice(start) &#125; process.exit(0); 在package.json文件内的scripts内增加脚本&quot;tpl&quot;: &quot;node GenerateTemplate&quot;运行命令为：tpl [moduleName] [generateType(c | p)] [rootDir]rootDir可填可不填,c为组件，p为页面，示例如下：yarn run tpl Home p 请求配置src文件夹内新建文件目录为utils/api/requst.ts import Taro from &quot;@tarojs/taro&quot;; const baseUrl = &quot;https://www.baidu.com/&quot;; interface params &#123; url: string data?: object, contentType?: string &#125; export const baseOptions = async (params: params, method: &quot;GET&quot; | &quot;OPTIONS&quot; | &quot;HEAD&quot; | &quot;POST&quot; | &quot;PUT&quot; | &quot;DELETE&quot; | &quot;TRACE&quot; | &quot;CONNECT&quot; | undefined = &quot;GET&quot;) =&gt; &#123; let &#123; url, data &#125; = params; let contentType: string = &quot;application/x-www-form-urlencoded&quot;; contentType = params.contentType || contentType; const option = &#123; url: baseUrl + url, data: data, method: method, header: &#123; &quot;content-type&quot;: contentType, &#125;, &#125;; try &#123; const result: any = await Taro.request(option); if (&quot;data&quot; in result &amp;&amp; result.data.code == 200) &#123; return Promise.resolve(result.data.data); &#125; else &#123; return Promise.reject(result.msg || &quot;请求出错&quot;); &#125; &#125; catch (error) &#123; return Promise.reject(&quot;请求出错&quot;); &#125; &#125; export const get = (url: string, data: object = &#123;&#125;): any =&gt; &#123; return baseOptions(&#123; url, data &#125;); &#125; export const post = (url: string, data: object, contentType?: string): any =&gt; &#123; return baseOptions(&#123; url, data, contentType &#125;, &quot;POST&quot;); &#125; or js version import Taro from &quot;@tarojs/taro&quot;; const base = &quot;https://www.easy-mock.com/mock/5ba4bd6191ddb5098ae2c0cd/api&quot;; export default &#123; baseOptions(params, method = &quot;GET&quot;) &#123; let &#123; url, data &#125; = params; // let token = getApp().globalData.token // if (!token) login() let contentType = &quot;application/x-www-form-urlencoded&quot;; contentType = params.contentType || contentType; const option = &#123; isShowLoading: false, loadingText: &quot;正在加载&quot;, url: base + url, data: data, method: method, header: &#123; &quot;content-type&quot;: contentType, token: token &#125;, success(res) &#123; return res.data; &#125;, error(e) &#123; return e; &#125; &#125;; return Taro.request(option); &#125;, get(url, data = &quot;&quot;) &#123; let option = &#123; url, data &#125;; return this.baseOptions(option); &#125;, post: function(url, data, contentType) &#123; let params = &#123; url, data, contentType &#125;; return this.baseOptions(params, &quot;POST&quot;); &#125; &#125;; 然后在同级新增index.ts import &#123; get, post &#125; from &#39;./requst&#39; export const test = (params?: object): any =&gt; get(&quot;index/getBanners&quot;, params); VScode配置自动重启按F5打开launch.json文件 &#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;小程序运行&quot;, &quot;runtimeExecutable&quot;: &quot;yarn&quot;, &quot;runtimeArgs&quot;: [ &quot;dev:weapp&quot;, ], &#125;, ] &#125; 运行时直接按Ctrl+F5来启动项目。 表单校验(yup)传送门yarn add yupyarn add -D @types/yup import * as yup from &#39;yup&#39; &lt;!-- 设置提示文字 必须在最上面 --&gt; yup.setLocale(&#123; mixed: &#123; required: &#39;$&#123;label&#125;是必填项&#39; &#125;, string: &#123; length: &#39;$&#123;label&#125;长度为$&#123;length&#125;位&#39;, &#125;, &#125;); &lt;!-- 设置数据类型与验证方式添加label 验证函数中直接传入的值直接为报错信息例：required(&#39;name不能为空&#39;)--&gt; this.state.schema = yup.object().shape(&#123; message: yup.string().required().label(&quot;Message&quot;), phone: yup.string().label(&quot;Phone&quot;).length(11), title: yup.string().required().label(&quot;Title&quot;), company: yup.string().required().label(&quot;Company&quot;), email: yup.string().required().label(&quot;Email&quot;), name: yup.string().required().label(&quot;Name&quot;), &#125;); &lt;!-- 验证数据是否通过，不通过返回错误信息 --&gt; this.state.schema.validate(sendData): Promise&lt;any, ValidationError&gt; &lt;!-- 验证单独属性是否通过，不通过返回错误信息 验证时同样传入全部数据 常用于输入时判断--&gt; schema.validateAt(&#39;name&#39;, sendData): Promise&lt;any, ValidationError&gt;; &lt;!-- 判断是否通过验证，返回布尔值 --&gt; schema.isValid(sendData): Promise&lt;boolean&gt;;","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"taro","slug":"taro","permalink":"http://yoursite.com/tags/taro/"}]},{"title":"vscode","slug":"code/vscode","date":"2019-07-16T02:25:00.000Z","updated":"2021-05-19T11:18:03.699Z","comments":true,"path":"2019/07/16/code/vscode/","link":"","permalink":"http://yoursite.com/2019/07/16/code/vscode/","excerpt":"","text":"相关配置&#123; //$&#123;workspaceRoot&#125; the path of the folder opened in VS Code(VSCode中打开文件夹的路径) //$&#123;workspaceRootFolderName&#125; (VSCode中打开文件夹的路径, 但不包含&quot;/&quot;) //$&#123;file&#125; the current opened file(当前打开的文件) //$&#123;relativeFile&#125; (当前打开的文件,相对于workspaceRoot) //$&#123;fileBasename&#125; (当前打开文件的文件名, 不含扩展名) //$&#123;fileDirname&#125; (当前打开文件的目录名) //$&#123;fileExtname&#125; (当前打开文件的扩展名) &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;(gdb) Launch&quot;,// 配置名称，将会在启动配置的下拉菜单中显示 &quot;type&quot;: &quot;cppdbg&quot;,// 配置类型，这里只能为cppdbg &quot;request&quot;: &quot;launch&quot;,// 请求配置类型，可以为launch（启动）或attach（附加） &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/detect/test/detect_demo&quot;,// 将要进行调试的程序的路径 &quot;args&quot;: [&quot;--rgb_video&quot;,&quot;/data/data/videos/car1_20170525.mp4&quot;],// 程序调试时传递给程序的命令行参数 &quot;stopAtEntry&quot;: false,// 设为true时程序将暂停在程序入口处，一般设置为false &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;/detect/test&quot;,// 可执行程序的启动路径 &quot;environment&quot;: [], &quot;externalConsole&quot;: true,// 调试时是否显示控制台窗口，一般设置为true显示控制台 &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ] &#125; ] &#125; 调试静态文件&#123; &quot;type&quot;: &quot;chrome&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;静态文件 Chapter 4&quot;, &quot;file&quot;: &quot;$&#123;workspaceFolder&#125;/Frontend dev-test/example/Chapter 4/index.html&quot;, &quot;webRoot&quot;: &quot;$&#123;workspaceFolder&#125;&quot; &#125;, 调试服务器文件&#123; &quot;type&quot;: &quot;chrome&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;sourceMaps&quot;: true, &quot;name&quot;: &quot;Launch Chrome&quot;, &quot;url&quot;: &quot;http://localhost:3000&quot;, &quot;webRoot&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;skipFiles&quot;: [ &quot;node_modules/**&quot; ], &quot;sourceMapPathOverrides&quot;: &#123; &quot;webpack:///*&quot;: &quot;$&#123;webRoot&#125;/*&quot;, &#125; &#125; 例调试react项目 &#123; &quot;type&quot;: &quot;chrome&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;sourceMaps&quot;: true, &quot;name&quot;: &quot;Launch Chrome&quot;, &quot;url&quot;: &quot;http://localhost:3000&quot;, &quot;webRoot&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;skipFiles&quot;: [ &quot;node_modules/**&quot; ], &quot;sourceMapPathOverrides&quot;: &#123; &quot;webpack:///*&quot;: &quot;$&#123;webRoot&#125;/*&quot;, &#125; &#125; 远程SFTP调试服务器文件使用vscode安装SFTP插件 &#123; &quot;name&quot;: &quot;My Server&quot;, &quot;host&quot;: &quot;ip address&quot;, &quot;protocol&quot;: &quot;sftp&quot;, &quot;port&quot;: 22, &quot;username&quot;: &quot;login&quot;, &quot;password&quot;: &quot;pwd&quot;, &quot;remotePath&quot;: &quot;/&quot;, &quot;connectTimeout&quot;:100000, &quot;uploadOnSave&quot;: true &#125; 相关插件设置毛玻璃 VibrancyVS内置浏览器 Browser Preview代码规范 JavaScript Booster自动匹配另一半标签 Bracket Pair Colorizer接口调试 REST Client代码截图 Polacode-2019注释高亮 Better Comments ！红色注释 ?蓝色注释 //灰色删除线注释 todo橘红色注释 *浅绿色注释 深色皮肤 Dracula Theme紫色主题 One Dark Pro图片预览 Image preview运行网页热更新 Live Server网页快捷在浏览器打开 open in browser项目快捷运行脚本 Quick Taskscss格式化 SCSS FormatterSFTP远程修改项目 SFTP高亮 SmartyTS格式化 TSLint (deprecated)VS图标 vscode-iconsJSON 格式化 vscode-json FlutterFlutter主体 FlutterFlutter快捷方式 Awesome Flutter Snippets ReactReact提示及快捷方式 ES7 React/Redux/GraphQL/React-Native snippetsTaro 快捷方式 taroSnippets VueVue主体 Veturwepy主体 Vetur-wepy Git便捷Git操作 Git History PythonPython主题 Python","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://yoursite.com/tags/vscode/"}]},{"title":"学习资源","slug":"other/study","date":"2019-07-11T08:20:00.000Z","updated":"2021-05-19T11:18:03.701Z","comments":true,"path":"2019/07/11/other/study/","link":"","permalink":"http://yoursite.com/2019/07/11/other/study/","excerpt":"","text":"字帖 跋王献之保母帖灵飞经微博字帖集","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/tags/%E8%B5%84%E6%BA%90/"},{"name":"书法","slug":"书法","permalink":"http://yoursite.com/tags/%E4%B9%A6%E6%B3%95/"}]},{"title":"Fabric.js","slug":"code/fabric","date":"2019-07-08T06:53:00.000Z","updated":"2021-05-19T11:18:03.695Z","comments":true,"path":"2019/07/08/code/fabric/","link":"","permalink":"http://yoursite.com/2019/07/08/code/fabric/","excerpt":"","text":"入门须知官网传送js引入或者包引入都可。body创建一个canvas标签加上id与宽高即可。 创建图形var canvas=new fabric.Canvas(&#39;box&#39;);//初始化canvasID才可 var rect=new fabric.Rect(&#123;//方形 left:40, top:40, fill:&#39;red&#39;, width:100, height:100, &#125;) var circle=new fabric.Circle(&#123;//圆圈 radius:50,//必须要有 left:200, top:200, fill:&#39;green&#39;, height:100, width:100, &#125;) var triangle=new fabric.Triangle(&#123;//三角形 width:80, height:100, fill:&quot;pink&quot;, left:300, top:300, &#125;) canvas.add(rect);//添加图形至画布中。 canvas.add(circle); canvas.add(triangle) 图片引入与操作fabric.Image.fromURL(&quot;./timg.jpg&quot;, function(img) &#123; // 可以进行任何操作后在渲染 img.scale(0.5); canvas.add(img);//此处引入后就不用在外面引入了。 &#125;); 不规则图形var path = new fabric.Path(&quot;M 0 0 L 200 200 L 100 200 z&quot;); // M代表移动 第一个为x轴第二为Y轴 L为路径的意思 z为结束的意思 path.set(&#123; left: 100, top: 100, fill: &quot;red&quot; &#125;); 动画设置官方教程 var rect = new fabric.Rect(&#123; left: 100, top: 100, width: 200, height: 200, fill: &quot;red&quot; &#125;); rect.set(&quot;angle&quot;, 30); rect.animate(&quot;left&quot;, &quot;+=360&quot;, &#123; //直接写数字是绝对角度，加上+=的话会加上之前定义的角度旋转 onChange: canvas.renderAll.bind(canvas), duration: 1000, easing: fabric.util.ease.easeOutBounce, &#125;); 图像过滤官方教程 fabric.Image.fromURL(&quot;./timg.jpg&quot;, function(img) &#123; img.scale(0.5); // add filter img.filters.push( new fabric.Image.filters.Grayscale(), //过滤方法官网查找 new fabric.Image.filters.Brightness(&#123; brightness: 0.2 &#125;), ); img.applyFilters(); // add image onto canvas (it also re-render the canvas) canvas.add(img); &#125;); 颜色模式及相互转换var canvas = new fabric.Canvas(&quot;box&quot;); var color1 = new fabric.Color(&quot;#f55&quot;); var color2 = new fabric.Color(&quot;#545648&quot;); var color3 = new fabric.Color(&quot;545648&quot;); var color4 = new fabric.Color(&quot;rgb(100,0,100)&quot;); var color5 = new fabric.Color(&quot;rgba(100,0,100,0.8)&quot;); var color11 = color1.toRgb(); var color22 = color2.toRgb(); var color33 = color3.toRgb(); var color44 = color4.toRgb(); var color55 = color5.toHex(); //只有rgb才有颜色，hex都是黑色 var color66 = color1.overlayWith(color5).toRgb(); //覆盖颜色 var rect = new fabric.Rect(&#123; left: 100, top: 100, width: 200, height: 200, fill: color55 &#125;); 渐变填充var circle = new fabric.Circle(&#123; left:100, top:100, width:100, height:300, radius:50, strokWidth:1,//边框 stroke:&#39;red&#39; &#125;) circle.setGradient(&#39;fill&#39;,&#123; x1:0, y1:0,//坐标点 x2:0, y2:circle.height, colorStops:&#123; 0:&#39;#00f&#39;, 0.2:&#39;orange&#39;,//这个是百分比渐变设置 1:&#39;#f00&#39; &#125; &#125;) 文字var text = new fabric.Text(&quot;hello word&quot;, &#123; left: 100, top: 100, fontFamily: &quot;Comic Sans&quot;, linethrough:true, fontSize:20 &#125;); 事件官方教程 var rect = new fabric.Rect(&#123; width: 100, height: 100, fill: &quot;red&quot; &#125;); rect.on(&quot;selected&quot;,function(point)&#123;//选中可以在选区上 console.log(point) &#125;) canvas.on(&quot;mouse:down&quot;, function(point) &#123;//点击只能在画布上 console.table(point.absolutePointer); &#125;);","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"搭建koa2项目","slug":"code/koa2","date":"2019-07-05T03:46:00.000Z","updated":"2021-05-19T11:18:03.695Z","comments":true,"path":"2019/07/05/code/koa2/","link":"","permalink":"http://yoursite.com/2019/07/05/code/koa2/","excerpt":"","text":"创建项目安装脚手架 npm install -g koa-generator创建项目 koa2 project_namekoa2项目文档routes文件夹中有三种展示方式可以选择 router.prefix(&#39;/users&#39;)//这个是前缀路径 #返回页面 router.get(&#39;/&#39;, async (ctx, next) =&gt; &#123; await ctx.render(&#39;index&#39;, &#123; title: &#39;Hello Koa 2!&#39; &#125;) &#125;) #返回字符串 router.get(&#39;/string&#39;, async (ctx, next) =&gt; &#123; ctx.body = &#39;koa2 string&#39; &#125;) #返回对象 router.get(&#39;/json&#39;, async (ctx, next) =&gt; &#123; ctx.body = &#123; title: &#39;koa2 json&#39; &#125; &#125;) bin/run(runkoa执行bin/www) bin/www是常规koa启动文件，和express的一样 views是放默认的jade文件 views-ejs是放ejs文件 链接mongodb引入mongoose包文件，根目录创建dbs文件夹，dbs下新建config.js与models文件夹。 // 配置mongo 地址 module.exports = &#123; dbs: &#39;mongodb://127.0.0.1:27017/dbs&#39; &#125; models文件夹中新建person.js文件 const mongoose = require(&#39;mongoose&#39;) // 创建数据表模型，该文件的名字，即person，就是数据表的名字 // 下面给 person 表声明两个字段name和age let personSchema = new mongoose.Schema(&#123; name: String, age: Number &#125;) // 通过建 model 给 person 赋予增删改查等读写的功能 module.exports = mongoose.model(&#39;Person&#39;, personSchema) // 一、引入mongoose const mongoose = require(&#39;mongoose&#39;) const dbConfig = require(&#39;./dbs/config&#39;) // 二、 连接数据库的服务 mongoose.connect(dbConfig.dbs, &#123; useNewUrlParser: true &#125;) 操作mongodb数据 // 引入mongo模型 const Person = require(&#39;../dbs/models/person&#39;) router.post(&#39;/addPerson&#39;, async function (ctx) &#123; // 创建实例 const person = new Person(&#123; name: ctx.query.name, age: ctx.query.age &#125;) let code = 0 // 状态码 try &#123; await person.save() code = 0 &#125; catch(e) &#123; console.log(e) code = -1 &#125; // 返回状态（成功为0， 错误为-1） ctx.body = &#123; code &#125; &#125;)","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"后台","slug":"后台","permalink":"http://yoursite.com/tags/%E5%90%8E%E5%8F%B0/"}]},{"title":"搭建Vue项目","slug":"code/vue","date":"2019-06-25T05:45:00.000Z","updated":"2021-05-19T11:18:03.699Z","comments":true,"path":"2019/06/25/code/vue/","link":"","permalink":"http://yoursite.com/2019/06/25/code/vue/","excerpt":"","text":"创建项目自行配置node环境 npm i -g @vue/cli vue create project_name （之后可以自行选择默认或者手动选择插件) eslint中的prettier选项为自动美化代码，不用操作直接撸。安装相关插件后使用vue add添加插件的配置就可以了配置选项（新建vue.config.js） 移动端适配rem适配adaptive.js npm install adaptive.js -S //在引入文件内引入该js import adaptive from &#39;adaptive.js&#39; //直接设置各种配置 adaptive.desinWidth = 750; adaptive.baseFont = 24; adaptive.scaleType = 3; // 1为默认值，可以不用设置 adaptive.init(); //即可生效 window[&#39;adaptive&#39;].desinWidth = 640; window[&#39;adaptive&#39;].baseFont = 24; window[&#39;adaptive&#39;].maxWidth = 480; window[&#39;adaptive&#39;].scaleType = 2; window[&#39;adaptive&#39;].init(); 转换第三方框架px内置适配Px2remloader地址 var px2remLoader = &#123; loader: &#39;px2rem-loader&#39;, options: &#123; remUnit: 75, // (这里是指设计稿的宽度为 750 / 10) remPrecision:5, min:1,//最小minpx的再小的不设置 &#125; &#125; vw适配（推荐）传送门注意：兼容第三方库就在设置里取消包含于ui库相同的字符串例selectorBlackList: [‘.ignore’, ‘.hairlines’,’van’], yarn add cssnano postcss-px-to-viewport postcss-write-svg cssnano-preset-advanced -D &quot;postcss&quot;: &#123; &quot;plugins&quot;: &#123; &quot;postcss-write-svg&quot;: &#123; &quot;utf8&quot;: false &#125;, &quot;postcss-px-to-viewport&quot;: &#123; &quot;viewportWidth&quot;: 750, &quot;viewportHeight&quot;: 1334, &quot;unitPrecision&quot;: 3, &quot;viewportUnit&quot;: &quot;vw&quot;, &quot;selectorBlackList&quot;: [ &quot;.ignore&quot;, &quot;.hairlines&quot;, &quot;van&quot; ], &quot;minPixelValue&quot;: 1, &quot;mediaQuery&quot;: false &#125;, &quot;cssnano&quot;: &#123; &quot;cssnano-preset-advanced&quot;: &#123; &quot;zindex&quot;: false, &quot;autoprefixer&quot;: false &#125; &#125; &#125; &#125;, Better-scroll插件npm install better-scroll –save &lt;template&gt; &lt;div ref=&quot;wrapper&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import BScroll from &quot;better-scroll&quot;; export default &#123; name: &quot;scroll-view&quot;, props: &#123; /** * 1 滚动的时候会派发scroll事件，会截流。 * 2 滚动的时候实时派发scroll事件，不会截流。 * 3 除了实时派发scroll事件，在swipe的情况下仍然能实时派发scroll事件 */ probeType: &#123; type: Number, default: 1 &#125;, /** * 点击列表是否派发click事件 */ click: &#123; type: Boolean, default: true &#125;, /** * 是否开启横向滚动 */ scrollX: &#123; type: Boolean, default: false &#125;, /** * 是否派发滚动事件 */ listenScroll: &#123; type: Boolean, default: false &#125;, /** * 列表的数据 */ data: &#123; type: Array, default: null &#125;, /** * 是否派发滚动到底部的事件，用于上拉加载 */ pullup: &#123; type: Boolean, default: false &#125;, /** * 是否派发顶部下拉的事件，用于下拉刷新 */ pulldown: &#123; type: Boolean, default: false &#125;, /** * 是否派发列表滚动开始的事件 */ beforeScroll: &#123; type: Boolean, default: false &#125;, /** * 当数据更新后，刷新scroll的延时。 */ refreshDelay: &#123; type: Number, default: 20 &#125; &#125;, mounted() &#123; this.$nextTick(() =&gt; &#123; this._initScroll(); &#125;); &#125;, methods: &#123; _initScroll() &#123; if (!this.$refs.wrapper) &#123; return; &#125; // better-scroll的初始化 let setData = &#123; probeType: this.probeType, click: this.click &#125;; if (this.scrollX) &#123; Object.assign(setData, &#123; scrollX: true, scrollY: false, eventPassthrough: &quot;vertical&quot; &#125;); &#125; else &#123; Object.assign(setData, &#123; eventPassthrough: &quot;horizontal&quot; &#125;); &#125; this.scroll = new BScroll(this.$refs.wrapper, setData); // 是否派发滚动事件 if (this.listenScroll) &#123; let me = this; this.scroll.on(&quot;scroll&quot;, pos =&gt; &#123; me.$emit(&quot;scroll&quot;, pos); &#125;); &#125; // 是否派发滚动到底部事件，用于上拉加载 if (this.pullup) &#123; const that=this; this.scroll.on(&quot;scrollEnd&quot;, () =&gt; &#123; // 滚动到底部 if (that.scroll.y &lt;= that.scroll.maxScrollY + 50) &#123; that.$emit(&quot;scrollToEnd&quot;); &#125; &#125;); &#125; // 是否派发顶部下拉事件，用于下拉刷新 if (this.pulldown) &#123; this.scroll.on(&quot;touchend&quot;, pos =&gt; &#123; // 下拉动作 if (pos.y &gt; 50) &#123; this.$emit(&quot;pulldown&quot;); &#125; &#125;); &#125; // 是否派发列表滚动开始的事件 if (this.beforeScroll) &#123; this.scroll.on(&quot;beforeScrollStart&quot;, () =&gt; &#123; this.$emit(&quot;beforeScroll&quot;); &#125;); &#125; &#125;, disable() &#123; // 代理better-scroll的disable方法 this.scroll &amp;&amp; this.scroll.disable(); &#125;, enable() &#123; // 代理better-scroll的enable方法 this.scroll &amp;&amp; this.scroll.enable(); &#125;, refresh() &#123; // 代理better-scroll的refresh方法 this.scroll &amp;&amp; this.scroll.refresh(); &#125;, scrollTo() &#123; // 代理better-scroll的scrollTo方法 this.scroll &amp;&amp; this.scroll.scrollTo.apply(this.scroll, arguments); &#125;, scrollToElement() &#123; // 代理better-scroll的scrollToElement方法 this.scroll &amp;&amp; this.scroll.scrollToElement.apply(this.scroll, arguments); &#125; &#125;, watch: &#123; // 监听数据的变化，延时refreshDelay时间后调用refresh方法重新计算，保证滚动效果正常 data() &#123; setTimeout(() =&gt; &#123; this.refresh(); &#125;, this.refreshDelay); &#125; &#125; &#125;; &lt;/script&gt; vee-validate表单验证yarn add vee-validate import VeeValidate, &#123; Validator &#125; from &#39;vee-validate&#39;; import zh_CN from &#39;vee-validate/dist/locale/zh_CN&#39;; Validator.localize(&#39;zh_CN&#39;, zh_CN); import * as validate from &#39;./validator&#39; Validator.extend(&#39;idCard&#39;, validate.idCard); Vue.use(VeeValidate, &#123; errorBagName: &#39;errors&#39;, // change if property conflicts. delay: 0, locale: &#39;zh_CN&#39;, messages: null, strict: true, &#125;); 自定义验证文件validator.js #getMessage方法为返回信息，validata方法为验证的方法,field为名称。 #身份证号 export const idCard = &#123; getMessage: field =&gt; field + &quot;不正确&quot;, validate: (value, args) =&gt; &#123; return /\\d&#123;17&#125;[\\d|x]|\\d&#123;15&#125;/.test(value) &#125; &#125; 使用验证 &lt;input name=&quot;idCard&quot; data-vv-as=&quot;身份证号&quot; v-validate=&quot;&#39;required|idCard|numeric&#39;&quot; v-model=&quot;form.idCard&quot; type=&quot;text&quot; placeholder=&quot;身份证号码&quot;&gt; 其他修改titlerouter.js routes: [ &#123; name:&#39;home&#39;, path: &#39;/home/:openname&#39;, component: Home, meta: &#123; title: &#39;首页&#39; &#125; &#125; ] 全局守卫router.beforeEach((to, from, next) =&gt; &#123; /* 路由发生变化修改页面title */ if (to.meta.title) &#123; document.title = to.meta.title; &#125; next(); &#125;) css引入本地图片background: url(&quot;~@/assets/img/shop/home_bg.png&quot;);","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"搭建react项目","slug":"code/react","date":"2019-06-25T03:21:00.000Z","updated":"2021-05-19T11:18:03.698Z","comments":true,"path":"2019/06/25/code/react/","link":"","permalink":"http://yoursite.com/2019/06/25/code/react/","excerpt":"","text":"创建项目自行配置node环境npx create-react-app project-name先使用git保存本地文件再yarn eject 开启配置模式如果需要sass就安装node-sass 根路径设置未使用react-app-rewiredwebpack.config.js中 alias: &#123; &#39;react-native&#39;: &#39;react-native-web&#39;, &quot;@&quot;: path.resolve(&#39;src&#39;),//新增根路径设置 &#125;, 使用react-app-rewired根目录新建config-overrides.js文件 const &#123; override, fixBabelImports, addWebpackAlias, addPostcssPlugins, disableEsLint &#125; = require(&quot;customize-cra&quot;); const path = require(&quot;path&quot;); const postcssAspectRatioMini = require(&quot;postcss-aspect-ratio-mini&quot;); const postcssPxToViewport = require(&quot;postcss-px-to-viewport&quot;); const postcssWriteSvg = require(&quot;postcss-write-svg&quot;); const postcssCssnext = require(&quot;postcss-cssnext&quot;); const cssnano = require(&quot;cssnano&quot;); module.exports = override( disableEsLint(),//关闭eslint fixBabelImports(&quot;import&quot;, &#123; libraryName: &quot;antd-mobile&quot;, style: true &#125;),//引入ant addWebpackAlias(&#123; &quot;@&quot;: path.resolve(&quot;src&quot;) //新增根路径设置 &#125;), addPostcssPlugins([ postcssAspectRatioMini(&#123;&#125;), // 用来处理元素容器宽高比 postcssWriteSvg(&#123; // 用来处理移动端1px的解决方案 utf8: false &#125;), postcssCssnext(&#123;&#125;), // 让项目使用CSS未来特性 并对其做兼容性处理 postcssPxToViewport(&#123; viewportWidth: 750, // 视窗的宽度，对应我们设计稿的宽度，一般是750 viewportHeight: 1334, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置 unitPrecision: 3, // 指定&#39;px&#39;转换为视窗单位值得小数位数（很多时候无法整除） viewportUnit: &quot;vw&quot;, // 指定需要转换成的视窗单位,建议使用vw selectorBlackList: [&quot;.ignore&quot;, &quot;.hairliness&quot;,&quot;.am&quot;], // 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名 minPixelValue: 1, // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值。 mediaQuery: false // 允许在媒体查询中转换`px` &#125;), cssnano(&#123; // 压缩和清理CSS代码 autoprefixer: false, &quot;postcss-zindex&quot;: false &#125;) ]) ); 配置路由yarn add react-router-domsrc根路径新建router.js配置页面路由然后在 app.js引入并替换 import React, &#123; Component &#125; from &#39;react&#39; import &#123; BrowserRouter, Switch, Route &#125; from &#39;react-router-dom&#39; import home from &#39;./pages/home/index&#39; import person from &#39;./pages/person/index&#39; export default class RouterConfig extends Component &#123; render() &#123; return ( &lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route path=&quot;/&quot; exact component=&#123;home&#125; /&gt; &lt;Route path=&quot;/person&quot; component=&#123;person&#125; /&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; ) &#125; &#125; import React from &#39;react&#39;; import RouterConfig from &#39;./router&#39; function App() &#123; return ( &lt;RouterConfig /&gt; ); &#125; export default App; 配置reduxyarn add redux redux-thunk react-redux在src中新建store目录,若分组开发则拆分reducer，根目录中组合各个reducer，若合并则直接在根目录中写入所有文件。 配置redux import &#123;createStore,applyMiddleware,compose,&#125; from &#39;redux&#39;; import thunk from &#39;redux-thunk&#39; import rootReducer from &#39;./reducers&#39;; // 定义浏览器方法（判断了是否是开发模式，否则不展示redux） const composeEnhancers = typeof window === &#39;object&#39; &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ &amp;&amp; (process.env.NODE_ENV === &quot;development&quot;) ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;) : compose; const enhancer = composeEnhancers( applyMiddleware(thunk), ); export default createStore( rootReducer, enhancer, ); # 不合并reducer的写法 const defaultState=&#123; inputVal:&quot;哈哈&quot;, list:[1,2,3,&quot;呼呼&quot;] &#125;; export default (state=defaultState,action)=&gt;&#123; return state &#125; # 合并reducer的写法 import &#123; combineReducers &#125; from &quot;redux&quot;; import home from &#39;../pages/home/store&#39; import person from &#39;../pages/person/store&#39; export default combineReducers(&#123; home, person &#125;) export default&#123; ADD_LIST:&quot;add_list&quot;, &#125; import ActionTypes from &#39;./actionTypes&#39; export default &#123; getAddItemAction: value =&gt; (&#123; type: ActionTypes.ADD_LIST, value &#125;), getTodoList: () =&gt; &#123; return (dispatch) =&gt; &#123; ajax(&quot;api/list&quot;).then(res =&gt; &#123; const action=creators.initListAction(res.data)//定义action dispatch(action) &#125;, err =&gt; &#123; console.log(err) &#125;) &#125; &#125; &#125; 组件内使用redux修改配置根目录的index.js import &#123;Provider&#125; from &#39;react-redux&#39; import store from &#39;./store&#39; const App=( &lt;Provider store=&#123;store&#125;&gt; &lt;Index /&gt; &lt;/Provider&gt; ) ReactDOM.render(App, document.getElementById(&#39;root&#39;)); 组件内调用redux import &#123;connect&#125; from &#39;react-redux&#39; import actions from &#39;@/store/actionCreators&#39; const mapStateToProps=(state)=&gt;&#123; return&#123; list:state.list &#125; &#125; const mapDispatchToProps=(dispatch)=&gt;&#123; return&#123; handleChange(e)&#123; const action =actions.getAddItemAction(e) dispatch(action) &#125; &#125; &#125; // 通过这个方法链接TodoList跟store export default connect(mapStateToProps,mapDispatchToProps)(TodoList) 引入ant yarn add antd react-app-rewired customize-cra babel-plugin-import yarn add antd-mobile react-app-rewired customize-cra babel-plugin-import &quot;scripts&quot;: &#123; - &quot;start&quot;: &quot;react-scripts start&quot;, + &quot;start&quot;: &quot;react-app-rewired start&quot;, - &quot;build&quot;: &quot;react-scripts build&quot;, + &quot;build&quot;: &quot;react-app-rewired build&quot;, - &quot;test&quot;: &quot;react-scripts test&quot;, + &quot;test&quot;: &quot;react-app-rewired test&quot;, &#125; 然后在项目根目录创建一个 config-overrides.js 用于修改默认配置。 const &#123; override, fixBabelImports &#125; = require(&#39;customize-cra&#39;); module.exports = override( fixBabelImports(&#39;import&#39;, &#123; libraryName: &#39;antd&#39;, libraryDirectory: &#39;es&#39;, style: true, &#125;), ); React-Bootstrap开始官网传送 安装yarn add react-bootstrap bootstrap在index.js/App.js中引入cssimport ‘bootstrap/dist/css/bootstrap.min.css’; 使用基本使用import &#123; Button &#125; from &#39;react-bootstrap&#39;; 隐藏classhidden 属性即为隐藏d-xl-block class用于在合适屏幕展示d-xl-none class用于在合适屏幕隐藏 引入immutebleimmuteble相关API fromJS(将对象转为immutable对象) toJS(将immutable对象转为js对象) get(获取对象值使用get方法) set(传入需要更改的值和更改后的内容) getIn(按照数组的顺序去取值) merge(改变多个值merge) 使用immuteble yarn add redux-immutable 在全局的reducer文件中更改引入方法combineReducers,不但redux有该插件也有，这样全局的都是immutable对象。 import { combineReducers } from “redux-immutable”; import &#123;combineReducers&#125; from &#39;redux-immutable&#39; import &#123;reducer as headerReducer&#125; from &#39;../common/header/store&#39; const reducer=combineReducers(&#123; header:headerReducer &#125;); export default reducer; 使用方法 // 因为值已经是immutable对象 ，如果想获取对象值使用get方法。 state.header.get(&quot;inputFocus&quot;) //或者 state.getIn([&quot;header&quot;,&quot;inputFocus&quot;])按照数组的顺序去取值 //更改需要使用方法set并传入需要更改的值和更改后的内容，immuteble会结合之前的值和更改的值返回一个全新的对象并不会更改之前的数据。 state.set(&quot;inputFocus&quot;,action.value) state.set(&quot;list&quot;, action.value).set(&quot;totalPage&quot;, action.totalPage) //或者改变多个值merge state.merge(&#123; list:action.value, totalPage:action.totalPage &#125;) //注意，该方法会将数据中的对象等改为普通数组。需要将里面的数据同样改成immuteble对象类型。 配置路由守卫配置路由结构 import React from &quot;react&quot;; import &#123; BrowserRouter, Switch, HashRouter &#125; from &quot;react-router-dom&quot;; import renderRoutesMap from &quot;./renderRoutesMap&quot;; import routerConfig from &quot;./routerConfig&quot;; // /** // * renderRoutes 渲染路由 // * @param &#123;array&#125; routes 路由列表 // * @param &#123;object&#125; extraProps = &#123;&#125; extra的属性 // * @param &#123;object&#125; switchProps = &#123;&#125; switch的属性 // */ const renderRoutes = (&#123; routes, extraProps = &#123;&#125;, switchProps = &#123;&#125; &#125;) =&gt; ( &lt;HashRouter&gt; &lt;Switch &#123;...switchProps&#125;&gt;&#123;renderRoutesMap(routes)&#125;&lt;/Switch&gt; &lt;/HashRouter&gt; ); // export default renderRoutes //index.js const router = () =&gt; renderRoutes(&#123; routes: routerConfig &#125;); export default router; 配置路由路径 const routes = [ &#123; path: &quot;/home&quot;, component: &quot;home&quot;,//都是路径名称并不是路径，结合真实路径写 authorization: true//是否需要权限 &#125;, &#123; path: &quot;/person&quot;, component: &quot;person&quot; &#125;, &#123; path: &quot;/edt&quot;, component: &quot;person/edt&quot; &#125;, &#123; // path: &quot;/&quot;,//path写/或不写都会是默认路由 component: &quot;load&quot; //若想没有404页面直接指向首页则将页面直接写home &#125; ]; export default routes; 配置路由高级组件 import RouterGuard from &quot;./routerGuard&quot;; import React from &quot;react&quot;; import &#123; Route &#125; from &quot;react-router-dom&quot;; const renderRoutesMap = routes =&gt; routes.map((route, index) =&gt; &#123; return ( &lt;Route key=&#123;index&#125; path=&#123;route.path&#125; extra=&#123;route.extra&#125; render=&#123;props =&gt; &lt;RouterGuard &#123;...route&#125; &#123;...props&#125; /&gt;&#125; /&gt; ); &#125;); export default renderRoutesMap; 配置路由的渲染封装（重要） import React, &#123; Component &#125; from &quot;react&quot;; import &#123; withRouter &#125; from &quot;react-router-dom&quot;; import Loadable from &quot;react-loadable&quot;;//动态加载页面可减小初始渲染大小 import &#123; connect &#125; from &quot;react-redux&quot;; import renderRoutesMap from &quot;./renderRoutesMap&quot;; const mapStateToProps = state =&gt; state; const mapDispatchToProps = dispatch =&gt; (&#123; ...dispatch &#125;); class RouterGuard extends Component &#123; constructor(props) &#123; super(props); &#125; componentWillMount() &#123; let &#123; history: &#123; replace &#125;, authorization, //登录权限 location &#125; = this.props; if (authorization) replace(&quot;/person&quot;);//权限在此处判断 if (location.pathname === &quot;/&quot;) &#123;//默认路由在此处判断并自动重定向 replace(&quot;/home&quot;); &#125; console.log(&quot;路由跳转前的拦截&quot;, this.props); &#125; render() &#123; let &#123; component, routes = [] &#125; = this.props; console.log(&quot;准备渲染compoent前&quot;, this.props); const LoadableComponent = Loadable(&#123; loader: () =&gt; import(`../pages/$&#123;component&#125;/index`), loading: () =&gt; &lt;span&gt;11111&lt;/span&gt;//页面加载前的加载页面 &#125;); return ( &lt;div&gt; &lt;LoadableComponent &#123;...this.props&#125; /&gt; &#123;renderRoutesMap(routes)&#125; &lt;/div&gt; ); &#125; &#125; export default withRouter( connect( mapStateToProps, mapDispatchToProps )(RouterGuard) ); React-Hookshooks的目的就是让你不再写class，让function一统江湖。useState是react自带的一个hook函数，它的作用是用来声明状态变量。 那我们从三个方面来看useState的用法，分别是声明、读取、使用（修改）。这三个方面掌握了，你基本也就会使用useState了. React Hooks不能出现在条件判断语句中，因为它必须有完全一样的渲染顺序。 state定义useState中传的值为默认值； import React, &#123; useState &#125; from &#39;react&#39;; function Example2()&#123; const [ age , setAge ] = useState(18) const [ sex , setSex ] = useState(&#39;男&#39;) const [ work , setWork ] = useState(&#39;前端程序员&#39;) return ( &lt;div&gt; &lt;p&gt;JSPang 今年:&#123;age&#125;岁&lt;/p&gt; &lt;p&gt;性别:&#123;sex&#125;&lt;/p&gt; &lt;p&gt;工作是:&#123;work&#125;&lt;/p&gt; &lt;/div&gt; ) &#125; export default Example2; useEffect代替生命周期学习React Hooks 时，我们要改掉生命周期函数的概念（人往往有先入为主的毛病，所以很难改掉），因为Hooks叫它副作用，所以componentWillUnmount也可以理解成解绑副作用。 componentDidMonut和componentDidUpdate第一次组件渲染和每次组件更新都会执行这个函数。 import React, &#123; useState , useEffect &#125; from &#39;react&#39;; function Example()&#123; const [ count , setCount ] = useState(0); //---关键代码---------start------- useEffect(()=&gt;&#123; console.log(`useEffect=&gt;You clicked $&#123;count&#125; times`) &#125;) //---关键代码---------end------- return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/button&gt; &lt;/div&gt; ) &#125; export default Example; 注意：React首次渲染和之后的每次渲染都会调用一遍useEffect函数，而之前我们要用两个生命周期函数分别表示首次渲染(componentDidMonut)和更新导致的重新渲染(componentDidUpdate)。 useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而componentDidMonut和componentDidUpdate中的代码都是同步执行的。个人认为这个有好处也有坏处吧，比如我们要根据页面的大小，然后绘制当前弹出窗口的大小，如果时异步的就不好操作了。 componentWillUnmount解绑实现return的函数即为解绑函数 function Index() &#123; useEffect(()=&gt;&#123; console.log(&#39;useEffect=&gt;老弟你来了！Index页面&#39;) return ()=&gt;&#123; console.log(&#39;老弟，你走了!Index页面&#39;) &#125; &#125;) return &lt;h2&gt;JSPang.com&lt;/h2&gt;; &#125; 那到底要如何实现类似componentWillUnmount的效果那?这就需要请出useEffect的第二个参数，它是一个数组，数组中可以写入很多状态对应的变量，意思是当状态值发生变化时，我们才进行解绑。但是当传空数组[]时，就是当组件将被销毁时才进行解绑，这也就实现了componentWillUnmount的生命周期函数。 function Index() &#123; useEffect(()=&gt;&#123; console.log(&#39;useEffect=&gt;老弟你来了！Index页面&#39;) return ()=&gt;&#123; console.log(&#39;老弟，你走了!Index页面&#39;) &#125; &#125;,[]) return &lt;h2&gt;JSPang.com&lt;/h2&gt;; &#125; 但是如果我们想每次count发生变化，我们都进行解绑，只需要在第二个参数的数组里加入count变量就可以了。 function Example()&#123; const [ count , setCount ] = useState(0); useEffect(()=&gt;&#123; console.log(`useEffect=&gt;You clicked $&#123;count&#125; times`) return ()=&gt;&#123; console.log(&#39;====================&#39;) &#125; &#125;,[count]) return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/button&gt; &lt;Router&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt; &lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/list/&quot;&gt;列表&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Route path=&quot;/&quot; exact component=&#123;Index&#125; /&gt; &lt;Route path=&quot;/list/&quot; component=&#123;List&#125; /&gt; &lt;/Router&gt; &lt;/div&gt; ) &#125; 实现props在用类声明组件时，父子组件的传值是通过组件属性和props进行的，那现在使用方法(Function)来声明组件，已经没有了constructor构造函数也就没有了props的接收，那父子组件的传值就成了一个问题。React Hooks 为我们准备了useContext。这节课就学习一下useContext，它可以帮助我们跨越组件层级直接传递变量，实现共享。需要注意的是useContext和redux的作用是不同的，一个解决的是组件之间值传递的问题，一个是应用中统一管理状态的问题，但通过和useReducer的配合使用，可以实现类似Redux的作用。 暂时不学了，感觉没啥大的作用只是换个方式写组件代理 package.json文件中顶部增加 “proxy”: “http://baidu.com&quot;, 仅写域名就可，会代理到该域名。 打包 如果是部署在后台服务除react-router的配置外还需要设置根路径为当前路径，package.json文件中顶部增加： “homepage”: “.”,","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"健身计划","slug":"learn/keep","date":"2019-06-24T01:29:00.000Z","updated":"2021-05-19T11:18:03.700Z","comments":true,"path":"2019/06/24/learn/keep/","link":"","permalink":"http://yoursite.com/2019/06/24/learn/keep/","excerpt":"","text":"目标 脂肪含量明显减少 力量提升 肌肉组织明显 规划 1.每隔一天去健身房锻炼一次 2.每次锻炼部分固定 3.每次多学习系统的方法 注意 不可超量屈伸，平时也要避免直腿直胳膊。 所有动作在发力时吐气，收力时吸气。 做动作中不可耸肩，发生耸肩的话就减轻分量。 动作一气呵成不可中断，不可到底。 发力时迅速，收力时缓慢。 拉伸时最少坚持30s 方法1.腿部训练腿部热身Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. 三组，每组20次，逐次增加重量。 杠铃硬拉背部保持挺直，髋关节向后送（骨盆前倾），屁股向下坐。 哑铃硬拉箭步蹲前面腿不弯曲，后腿尽量向下，跨度始终尽量可以锻炼到大腿与臀部。 深蹲背部挺直，髋部向后 1. 热身跑步10min2. 箭步蹲：左右腿蹲为1次共10次，组间休息30s，5组3. 腿屈伸：前三组大重量8-10RM，组间加上卷腹（上腹）不休息。共6组4. 腿伸展：前三组大重量8-10RM，组间休息50s，后3组轻重量12-15RM，组间加上卷腹（下腹），不休息。共6组5. 深蹲：前3组70KG-8RM，组间休息1min。后3组40KG-12RM，组间加上 卷腹（侧腹），不休息。共6组6. 椭圆仪：40min7. 拉伸 2.背部训练杠铃划船 双脚与肩同宽，挺胸抬头背部挺直，双膝微屈，双手正握单杠宽比双腿宽一点点，上身保持并向下尽力趴下去。肘部保持夹紧，放松时双臂放松，单杠在膝盖前一点，然后背部发力带动双臂将单杠沿着膝盖拖到小腹为止，然后再缓慢收回。 哑铃划船 左边为例，右腿跪在坐垫，右手稍微弯曲扶着坐垫。左腿向后撤，左手垂直侧正拿哑铃，发力时以背部带动左手向左后方发力实现背部的左下方肌肉得到锻炼。反之亦然 高位下拉 坐在哑铃上，双臂抓横杠，保持肩胛骨收紧，挺胸抬头收腹，发力时胸部向前挺，拉至横杠于胸部上方。 坐姿划船 坐在哑铃上，挺胸抬头，肩胛骨收紧，发力时胸部向前挺，肘部夹紧，将把手拉直肚脐处为止，收力时身体稍微向前送出。 引体向上 挺胸收腹，肩胛骨收紧，双手抓把手中间，放松到大小臂90度夹角即可，向上头刚刚超过横杠即可。 固定器械高位下拉 挺胸收腹，肩胛骨收紧，双手抓把手中间，用胸部发力去带动胳膊向后收。 背部拉伸找个一米多高的地方，双手抓住，身体向下坐使背部得到拉伸。 1. 跑步热身10min2. 哑铃划船：（轻重量热身）4组每组15-20次3. 单臂哑铃划船：合适重量5组，每组15次（注重离心，顶峰收缩）4. 高位下拉：中重量5组，每组15次（注重离心，顶峰收缩）5. 杠铃划船：中重量3组，每组15次 低重量3组 每组20次6. 坐姿划船：中重量5组 每组15次（注重离心，顶峰收缩）7. 山羊挺身：每组15次/5组8. 硬拉：中重量3组每组15次 低重量3组 每组20次9. 腹肌撕裂1组10. 有氧40min11. 拉伸 3.胸部训练胸部热身 挺胸收腹，肩胛骨收紧，双手抓把手中间，用胸部发力去带动胳膊向后收。 史密斯杠铃卧推Your browser does not support the video tag. 平躺在坐垫上，小臂与大臂成90度夹角抓住杠铃，肩胛骨夹紧，向上直直推出，保持杠铃下来后在乳头上方，动作幅度大。(中部胸肌) 杠铃上斜卧推 反坐在坐垫上，小臂与大臂成90度夹角抓住杠铃，肩胛骨夹紧，保持杠铃下来后在锁骨上方，动作幅度大。(上部胸肌) 双杠臂曲伸 抓住中间把手，下巴抵住锁骨，背部拱起成C字型，肘部夹紧。 胸部拉伸右胸为例，找面墙壁，右腿弓布向前，右臂大小臂呈垂直放在墙的另一面，身体向左前方发力，使右边有拉伸的感觉。左胸反之亦然 1. 跑步热身10min2. 肩部热身3. 杠铃上斜卧推：20kg/8-12RM 2组 10kg/12-15RM 3组4. 哑铃上斜卧推：24kg/8-12RM 2组 8kg一边/12-15RM 3组5. 史密斯杠铃卧推：40kg/8RM 2组 20kg/12RM 3组6. 哑铃卧推：24kg/8-12RM2组 8kg一边/12-15RM 3组7. 龙门架夹胸（下胸）中重量5组 每组15次8. 哑铃卧推（下胸）20kg/8-12RM 2组 8kg一边/12-15RM 3组9. Keep腹肌撕裂进阶10. 有氧30-40min11. 拉伸 4.肩部训练 &#123;% video /assets/media/1keep.mp4 %&#125; &#123;% video /assets/media/19keep.mp4 %&#125; &#123;% video /assets/media/6keep.mp4 %&#125; &#123;% video /assets/media/7keep.mp4 %&#125; &#123;% video /assets/media/14keep.mp4 %&#125; &#123;% video /assets/media/9keep.mp4 %&#125; &#123;% video /assets/media/11keep.mp4 %&#125; &#123;% video /assets/media/5keep.mp4 %&#125; 颈前推举小臂垂直于地面，双手抓正，肩膀下沉 颈后推举小臂垂直于地面，双手抓正，肩膀下沉 反向飞鸟哑铃肩部推举哑铃前平举1. 跑步热身10min2. 肩部肌肉+关节热身3. 史密斯颈前推举：5组/12-15次（中重量）（顶峰收缩）4. 哑铃前平举：10kg 5组/12-15次5. 哑铃肩部推举：5组/12-15次6. 哑铃侧平举：8kg 5组/12-15次7. 哑铃俯身侧平举：8kg 5组/12-15次8. 反向飞鸟：5组/12-15次9. 腹肌撕裂+有氧40min10. 拉伸 5.手臂训练Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. Your browser does not support the video tag. 哑铃弯举大臂放在垫子前侧并保证紧贴，小臂发力向上举起哑铃。 曲杠铃弯举：（窄握）双臂大臂紧贴垫子，手握中间两个曲杠。尽力向下放到底再拉起。 曲杠铃弯举：（宽握）双臂大臂紧贴垫子，手握靠外两个曲杠。 俯卧哑铃弯举双脚与肩同宽，提臀收腹髋关节向前，上身向前探出，一只手扶着物体，另一只手大臂带动小臂向上拉起哑铃。 背后提哑铃坐在椅子上背部挺直，大臂伸到头上向外倾斜一点，小臂在背后手持哑铃通过大臂发力上下运动 坐姿起身双手按住椅子，臀部腾空靠前，身体向下落胳膊在身后按住椅子发力使身体向上。 手臂拉伸双手举起手在眼睛旁边约十厘米外胳膊抬起，双手向斜上方快速伸直与收回。左臂从脑后伸向右边，右臂从脑后扳住左臂的大臂发力形成撕扯感。 1. 跑步10min热身2. 哑铃弯举：（轻重量）热身（快速）30个一组/2组3. 曲杠铃弯举：（窄握）（长头/外侧头）合适重量，顶峰收缩，2组/10次4. 曲杠铃弯举：（宽握）（短头/内侧头）合适重量，顶峰收缩，2组/10次5. 俯卧哑铃弯举：（长头）合适重量，顶峰收缩，2组/10次6. 仰卧哑铃弯举：（短头）合适重量，顶峰收缩，2组/10次7. 锤式弯举，合适重量，3组/12次8. 三头外侧头：哑铃俯身曲臂伸（手腕向外侧旋） 3组/12次+绳索下拉开肘 2组/15次9. 三头内测头：反手绳索下压（夹肘）3组/12次+绳索下拉夹肘2组/15次10. 长头：颈后臂屈伸（单手）3组/8次11. 腹肌撕裂进阶+有氧40min12. 拉伸","categories":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"健身","slug":"健身","permalink":"http://yoursite.com/tags/%E5%81%A5%E8%BA%AB/"}]},{"title":"开发博客网站","slug":"code/blog","date":"2019-06-21T08:41:01.000Z","updated":"2021-05-19T11:18:03.694Z","comments":true,"path":"2019/06/21/code/blog/","link":"","permalink":"http://yoursite.com/2019/06/21/code/blog/","excerpt":"","text":"博客开发基于hexo的Volantis博客主题模版开发 免费cdn加速(不配置cdn会超级慢)使用jsDelivr的方式配置个人cdn，但是每次修改资源都需要重新发行。传送门贴图库申请个账号直接拉进去就能用，我把图片都放这个里面了。传送门还有其他的cdn方法没有用过。传送门 服务器配置上阿里云买个学生的服务器就够使用，装个nginx,然后开一个端口配置下路径即可。 server &#123; listen 80; server_name dd6688.club; location / &#123; root /home/my_space_formal; try_files $uri $uri/ /index.html; &#125; &#125; hexo 常用命令hexo d -g 生成静态文件后直接推送git &#123;% fb_img https://cdn.jsdelivr.net/gh/dxc0522/cdn_assets@3.7/keep/1keep.jpg 健身 %&#125; 插入的可放大的图片 然后就没有然后了","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"面试题","slug":"other/face","date":"2019-06-21T08:41:01.000Z","updated":"2021-05-19T11:18:03.701Z","comments":true,"path":"2019/06/21/other/face/","link":"","permalink":"http://yoursite.com/2019/06/21/other/face/","excerpt":"","text":"HTML浏览器运行机制1，构建DOM树，将标签转为DOM node（节点，包括js生成的标签）2，构建渲染树：解析所有的css样式文件信息3，布局渲染书：从根节点递归调用，计算每一个元素的大小位置给出精确坐标4，绘制渲染书：遍历渲染树，使用UI层来绘制每个节点。 重绘指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性进行新属性重新绘制，使元素呈现新的外观。color，background-color等会触发重绘。 重排（重构、回流、reflow）当渲染树中的一部分或全部因为元素的规模尺寸布局隐藏等改变而需要重新构建，这就成为回流（reflow）。每个页面至少需要一次回流，就是在页面第一次加载的时候。任何页面布局和几何属性改变都会触发重排。 重绘和重排的关系在回流的时候浏览器会使渲染树中收到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器就会重新绘制受影响的部分到屏幕中，该过程称为重绘。所以，重排必定引发重绘，重绘不一定会引发重排。 优化方案1、直接修改元素的className2、先设置display:none;然后修改元素，然后在设置display：block；3、让它脱离文档流4、创建完dom一次性加入 ReactReact生命周期有哪些初始化阶段constructor 构造函数getDefaultProps props默认值getInitialState state默认值挂载阶段staticgetDerivedStateFromProps(props,state)rendercomponentDidMountgetDerivedStateFromProps：组件每次被 rerender的时候，包括在组件构建之后(虚拟 dom之后，实际 dom挂载之前)，每次获取新的 props或 state之后；每次接收新的props之后都会返回一个对象作为新的 state，返回null则说明不需要更新 state；配合 componentDidUpdate，可以覆盖 componentWillReceiveProps的所有用法更新阶段staticgetDerivedStateFromProps(props,state)shouldComponentUpdaterendergetSnapshotBeforeUpdate(prevProps,prevState)componentDidUpdategetSnapshotBeforeUpdate：触发时间: update发生的时候，在 render之后，在组件 dom渲染之前；返回一个值，作为 componentDidUpdate的第三个参数；配合 componentDidUpdate, 可以覆盖 componentWillUpdate的所有用法卸载阶段componentWillUnmount错误处理componentDidCatchReact16新的生命周期弃用了 componentWillMount、componentWillReceivePorps，componentWillUpdate新增了 getDerivedStateFromProps、getSnapshotBeforeUpdate来代替弃用的三个钩子函数。 React16并没有删除这三个钩子函数，但是不能和新增的钩子函数混用， React17将会删除这三个钩子函数，新增了对错误的处理（ componentDidCatch） setState是同步的还是异步的？在 React的生命周期和合成事件中， React仍然处于他的更新机制中，这时无论调用多少次 setState，都会不会立即执行更新，而是将要更新的·存入 _pendingStateQueue，将要更新的组件存入 dirtyComponent。 当上一次更新机制执行完毕，以生命周期为例，所有组件，即最顶层组件 didmount后会将批处理标志设置为 false。这时将取出 dirtyComponent中的组件以及 _pendingStateQueue中的 state进行更新。这样就可以确保组件不会被重新渲染多次。 所以。setState本身并不是异步的，而是 React的批处理机制给人一种异步的假象。 在原生事件中调用 setState并不会出发 React的批处理机制，所以立即能拿到最新结果。 为什么有时连续多次setState只有一次生效？原因就是 React会批处理机制中存储的多个 setState进行合并，注意， assign函数中对函数做了特殊处理，处理第一个参数传入的是函数，函数的参数 preState是前一次合并后的结果。 虚拟Dom比普通Dom更快吗？直接操作 DOM是非常耗费性能的，这一点毋庸置疑。但是 React使用 VitrualDom也是无法避免操作 DOM的。如果是首次渲染， VitrualDom不具有任何优势，甚至它要进行更多的计算，消耗更多的内存。VitrualDom的优势在于 React的 Diff算法和批处理策略， React在页面更新之前，提前计算好了如何进行更新和渲染 DOM。实际上，这个计算过程我们在直接操作 DOM时，也是可以自己判断和实现的，但是一定会耗费非常多的精力和时间，而且往往我们自己做的是不如 React好的。所以，在这个过程中 React帮助我们”提升了性能”。 所以，我更倾向于说， VitrualDom帮助我们提高了开发效率，在重复渲染时它帮助我们计算如何更高效的更新，而不是它比 DOM操作更快。 React如何实现自己的事件机制？React事件并没有绑定在真实的 Dom节点上，而是通过事件代理，在最外层的 document上对事件进行统一分发。组件挂载、更新时： 通过 lastProps、 nextProps判断是否新增、删除事件分别调用事件注册、卸载方法。调用 EventPluginHub的 enqueuePutListener进行事件存储获取 document对象。根据事件名称（如 onClick、 onCaptureClick）判断是进行冒泡还是捕获。判断是否存在 addEventListener方法，否则使用 attachEvent（兼容IE）。给 document注册原生事件回调为 dispatchEvent(统一的事件分发机制）。事件初始化： EventPluginHub负责管理 React合成事件的 callback，它将 callback存储在 listenerBank中，另外还存储了负责合成事件的 Plugin。获取绑定事件的元素的唯一标识 key。将 callback根据事件类型，元素的唯一标识 key存储在 listenerBank中。listenerBank的结构是： listenerBank[registrationName][key]。触发事件时： 触发 document注册原生事件的回调 dispatchEvent获取到触发这个事件最深一级的元素遍历这个元素的所有父元素，依次对每一级元素进行处理。构造合成事件。将每一级的合成事件存储在 eventQueue事件队列中。遍历 eventQueue。通过 isPropagationStopped判断当前事件是否执行了阻止冒泡方法。如果阻止了冒泡，停止遍历，否则通过 executeDispatch执行合成事件。释放处理完成的事件。 为何React事件要自己绑定this？在上面提到的事件处理流程中， React在 document上进行统一的事件分发， dispatchEvent通过循环调用所有层级的事件来模拟事件冒泡和捕获。 在 React源码中，当具体到某一事件处理函数将要调用时，将调用 invokeGuardedCallback方法。 function invokeGuardedCallback(name,func,a)&#123; try&#123; func(a); &#125; catch(x)&#123; if(caughtError ===null)&#123; caughtError =x; &#125; &#125; &#125; 原生事件和React事件的区别？React 事件使用驼峰命名，而不是全部小写。 通过 JSX , 你传递一个函数作为事件处理程序，而不是一个字符串。 在 React 中你不能通过返回 false 来阻止默认行为。必须明确调用 preventDefault。 React和原生事件的执行顺序是什么？可以混用吗？React的所有事件都通过 document进行统一分发。当真实 Dom触发事件后冒泡到 document后才会对 React事件进行处理。 所以原生的事件会先执行，然后执行 React合成事件，最后执行真正在 document上挂载的事件 React事件和原生事件最好不要混用。原生事件中如果执行了 stopPropagation方法，则会导致其他 React事件失效。因为所有元素的事件将无法冒泡到 document上，导致所有的 React事件都将无法被触发。。 虚拟Dom是什么？在原生的 JavaScript程序中，我们直接对 DOM进行创建和更改，而 DOM元素通过我们监听的事件和我们的应用程序进行通讯。 而 React会先将你的代码转换成一个 JavaScript对象，然后这个 JavaScript对象再转换成真实 DOM。这个 JavaScript对象就是所谓的虚拟 DOM。 当我们需要创建或更新元素时， React首先会让这个 VitrualDom对象进行创建和更改，然后再将 VitrualDom对象渲染成真实DOM。 当我们需要对 DOM进行事件监听时，首先对 VitrualDom进行事件监听， VitrualDom会代理原生的 DOM事件从而做出响应。 为什么React组件首字母必须大写？babel在编译时会判断 JSX中组件的首字母，当首字母为小写时，其被认定为原生 DOM标签， createElement的第一个变量被编译为字符串；当首字母为大写时，其被认定为自定义组件， createElement的第一个变量被编译为对象； 什么是高阶组件？如何实现？高阶组件可以看作 React对装饰模式的一种实现，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。 Hook有哪些优势？减少状态逻辑复用的风险Hook和 Mixin在用法上有一定的相似之处，但是 Mixin引入的逻辑和状态是可以相互覆盖的，而多个 Hook之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上。在不遵守约定的情况下使用 HOC也有可能带来一定冲突，比如 props覆盖等等，使用 Hook则可以避免这些问题。 避免地狱式嵌套大量使用 HOC的情况下让我们的代码变得嵌套层级非常深，使用 HOC，我们可以实现扁平式的状态逻辑复用，而避免了大量的组件嵌套。 让组件更容易理解在使用 class组件构建我们的程序时，他们各自拥有自己的状态，业务逻辑的复杂使这些组件变得越来越庞大，各个生命周期中会调用越来越多的逻辑，越来越难以维护。使用 Hook，可以让你更大限度的将公用逻辑抽离，将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割。 使用函数代替class相比函数，编写一个 class可能需要掌握更多的知识，需要注意的点也越多，比如 this指向、绑定事件等等。另外，计算机理解一个 class比理解一个函数更快。Hooks让你可以在 classes之外使用更多 React的新特性。","categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/tags/%E8%B5%84%E6%BA%90/"}]},{"title":"游戏资源","slug":"other/game","date":"2019-06-20T08:16:01.000Z","updated":"2021-05-19T11:18:03.701Z","comments":true,"path":"2019/06/20/other/game/","link":"","permalink":"http://yoursite.com/2019/06/20/other/game/","excerpt":"","text":"在某宝买显卡送了这些游戏 特来分享给大家 链接我没有一一测试 请自行测试 战争游戏：红龙 链接：https://pan.baidu.com/s/1pLHUgQJ 密码：5iex NBA2K18 链接：https://pan.baidu.com/s/1dEA5SrR 密码：crp6 无双全明星 链接：https://pan.baidu.com/s/1miEBjPu 密码：nig1 巫师3狂猎 链接：https://pan.baidu.com/s/1bpwBW79 密码：tcnd 文明6 链接：https://pan.baidu.com/s/1jHRS6sm 密码：w2dn 看门狗 链接：https://pan.baidu.com/s/1jHRS6sm 密码：w2dn 丧尸围城4 链接：https://pan.baidu.com/s/1mhW6Z5Q 密码：0y2e 全面战争：战锤 链接：https://pan.baidu.com/s/1o89cBLS 密码：ks6k 英雄无敌7 链接：https://pan.baidu.com/s/1qYGzALA 密码：h2ja 信长野望：战国立志传 链接：https://pan.baidu.com/s/1jHS5ASI 密码：r2az 哥萨克 链接：https://pan.baidu.com/s/1hszdImC 密码：f6w0 家园重置收藏版 链接：https://pan.baidu.com/s/1c229Ej2 密码：k9p8 三国志13 链接：https://pan.baidu.com/s/1sluGHx7 密码：mrqe 战地：硬仗 https://pan.baidu.com/s/1qYJLeGG 英雄连 链接：https://pan.baidu.com/s/1i5mPsVF 密码：zv7j 拿破仑：全面战争 链接：https://pan.baidu.com/s/1o7SwsDO 密码：35pa 黑暗之魂3 链接：https://pan.baidu.com/s/1pKEgUqZ 密码：ugke NBA2K17传奇版 链接：https://pan.baidu.com/s/1jHTPIGe 密码：m8ef 战地1 链接：https://pan.baidu.com/s/1o7GQkRo 密码：0495 圣域1+魔都魅影 链接：https://pan.baidu.com/s/1i4ZqHUl 密码：qav0 正当防卫3 链接：https://pan.baidu.com/s/1c1WILyC 密码：dyvi 杀手6 链接：https://pan.baidu.com/s/1cu3tKU 密码：o45b 国土防线2 链接：https://pan.baidu.com/s/1hrS6KL2 密码：jizy 虐杀原形1 链接：https://pan.baidu.com/s/1qXKiAYg 密码：i2i6 钢铁雄心3 链接：https://pan.baidu.com/s/1hr6QpSw 密码：2dkw 质量效应1 链接：https://pan.baidu.com/s/1o8bfiEA 密码：r8as 孤岛惊魂：原始杀戮 链接：https://pan.baidu.com/s/1hsbqspI 密码：nexy 模拟人生3全集 链接：https://pan.baidu.com/s/1pLtsqjp 密码：d9ti 三国无双7帝国 链接：https://pan.baidu.com/s/1eRDDkHW 密码：dwvq 火影忍者：究极忍者风暴3 链接：https://pan.baidu.com/s/1c1FddmS 密码：9hai GTA5 侠盗猎车5 https://pan.baidu.com/s/1skFswmL 孤岛惊魂2 链接：https://pan.baidu.com/s/1hsJoDuc 密码：2bxg 战地４ 链接：https://pan.baidu.com/s/1kVFKDIR 密码：m6op 美国卡车模拟 链接：https://pan.baidu.com/s/1bo171z5 密码：syv9 波斯王子4 链接：https://pan.baidu.com/s/1dEZZcMP 密码：cbjk 生化危机系列 链接：https://pan.baidu.com/s/1slIVGrN 密码：xou0 实况2016 https://pan.baidu.com/s/1jIHNMey 耻辱 链接：https://pan.baidu.com/s/1kUOrdqB 密码：jt8z 鬼泣5 链接：https://pan.baidu.com/s/1dEJdz8l 密码：y0vw 钢铁雄心4 链接：https://pan.baidu.com/s/1nuKiZw9 密码：8un4 信长野望：创造 链接：https://pan.baidu.com/s/1i5oJrwD 密码：yefe 量子破碎 链接：https://pan.baidu.com/s/1kVI1sFl 密码：uajd 杀出重围:分裂 链接：https://pan.baidu.com/s/1mhYxKAO 密码：oypy 龙珠 链接：https://pan.baidu.com/s/1pLNc39p 密码：6f14 生化危机：启示录 链接：https://pan.baidu.com/s/1gfMCNf1 密码：ezld 质量效应2 链接：https://pan.baidu.com/s/1hsI6WmC 密码：furc 鬼泣4特别版 链接：https://pan.baidu.com/s/1mhZJz9e 密码：if01 使命13无限战争 链接：https://pan.baidu.com/s/1i4Cjauh 密码：onjx 镜之边缘：催化剂 链接：https://pan.baidu.com/s/1c263MjY 密码：tf3p 上古卷轴5高清重制版 链接：https://pan.baidu.com/s/1hrNGiZq 密码：zz93 家园重置版 链接：https://pan.baidu.com/s/1pLaZfVP 密码：lbvy 妖精剑士F 链接：https://pan.baidu.com/s/1i5fpbEl 密码：8wrr 侍道4 链接：https://pan.baidu.com/s/1qXDW2eg 密码：y20h 圣域2 链接：https://pan.baidu.com/s/1eR75oUQ 密码：5ji7 工人物语7 链接：https://pan.baidu.com/s/1dFwYh4t 密码：qexe 彩虹六号围攻 链接：https://pan.baidu.com/s/1gfG6S7p 密码：4d6r 变形金刚：毁灭 链接：https://pan.baidu.com/s/1bp3hR6f 密码：v7q8 讨鬼极传 链接：https://pan.baidu.com/s/1qXHupC4 密码：yu6u 帝国：全面战争 链接：https://pan.baidu.com/s/1bAvnxs 密码：ytkl 亚尔斯兰战记X无双 链接：https://pan.baidu.com/s/1pKJyk4b 密码：4qez 最终幻想：零式HD 链接：https://pan.baidu.com/s/1pKJyk4b 密码：4qez 最终幻想13 链接：https://pan.baidu.com/s/1gf8zyM3 密码：hgf1 剑勇传奇：忍者龙剑传 链接：https://pan.baidu.com/s/1pK88Lgn 密码：wjk9 纪元2205 链接：https://pan.baidu.com/s/1i519Gfr 密码：ktmz 勇者斗恶龙：英雄 链接：https://pan.baidu.com/s/1c1HIE4o 密码：i973 小镇惊魂：黑暗守护者 链接：https://pan.baidu.com/s/1bppADeJ 密码：xn2n 超级房车赛：汽车运动 链接：https://pan.baidu.com/s/1dEDCT7j 密码：i6tt 忍者神龟：冲出阴暗 链接：https://pan.baidu.com/s/1mh7sYqk 密码：g1wx 忍者神龟：马哈顿突变 链接：https://pan.baidu.com/s/1qXURy00 密码：m4aj 僵尸 链接：https://pan.baidu.com/s/1c1CtbW0 密码：fc8z 海贼无双 链接：https://pan.baidu.com/s/1mi79mmk 密码：iqp8 世界汽车拉力锦标赛5 链接：https://pan.baidu.com/s/1slrkchR 密码：7jf8 魔法门英雄交锋 链接：https://pan.baidu.com/s/1i5e9fPr 密码：mlue 方舟生存进化 链接：https://pan.baidu.com/s/1jIDcX1c 密码：l8vx 冥河：暗影大师 链接：https://pan.baidu.com/s/1c1VpP2g 密码：7uag 海岛大亨5 链接：https://pan.baidu.com/s/1o7Ea1Oe 密码：5wof 神界3 链接：https://pan.baidu.com/s/1c1NVfo 密码：osee","categories":[{"name":"娱乐","slug":"娱乐","permalink":"http://yoursite.com/categories/%E5%A8%B1%E4%B9%90/"}],"tags":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/tags/%E8%B5%84%E6%BA%90/"}]},{"title":"技术资源","slug":"other/system","date":"2019-06-20T06:00:00.000Z","updated":"2021-05-19T11:18:03.701Z","comments":true,"path":"2019/06/20/other/system/","link":"","permalink":"http://yoursite.com/2019/06/20/other/system/","excerpt":"","text":"开发sublime下载 ZYNGA INC. 50 User License EA7E-811825 927BA117 84C9300F 4A0CCBC4 34A56B44 985E4562 59F2B63B CCCFF92F 0E646B83 0FD6487D 1507AE29 9CC4F9F5 0A6F32E3 0343D868 C18E2CD5 27641A71 25475648 309705B3 E468DDC4 1B766A18 7952D28C E627DDBA 960A2153 69A2D98A C87C0607 45DC6049 8C04EC29 D18DFA40 442C680B 1342224D 44D90641 33A3B9F2 46AADB8F 系统VMware虚拟机 YG5H2-ANZ0H-M8ERY-TXZZZ-YKRV8 UG5J2-0ME12-M89WY-NPWXX-WQH88 UA5DR-2ZD4H-089FY-6YQ5T-YPRX6 GA590-86Y05-4806Y-X4PEE-ZV8E0 ZF582-0NW5N-H8D2P-0XZEE-Z22VA YA18K-0WY8P-H85DY-L4NZG-X7RAD charles激活License Key: 48891cf209c6d32bf4神龙激活win","categories":[{"name":"系统","slug":"系统","permalink":"http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/tags/%E8%B5%84%E6%BA%90/"}],"author":"豆豆"}],"categories":[{"name":"开发","slug":"开发","permalink":"http://yoursite.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"学习","slug":"学习","permalink":"http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"娱乐","slug":"娱乐","permalink":"http://yoursite.com/categories/%E5%A8%B1%E4%B9%90/"},{"name":"系统","slug":"系统","permalink":"http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"后台","slug":"后台","permalink":"http://yoursite.com/tags/%E5%90%8E%E5%8F%B0/"},{"name":"系统","slug":"系统","permalink":"http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F/"},{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"基金","slug":"基金","permalink":"http://yoursite.com/tags/%E5%9F%BA%E9%87%91/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://yoursite.com/tags/TypeScript/"},{"name":"App","slug":"App","permalink":"http://yoursite.com/tags/App/"},{"name":"开发","slug":"开发","permalink":"http://yoursite.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"taro","slug":"taro","permalink":"http://yoursite.com/tags/taro/"},{"name":"vscode","slug":"vscode","permalink":"http://yoursite.com/tags/vscode/"},{"name":"资源","slug":"资源","permalink":"http://yoursite.com/tags/%E8%B5%84%E6%BA%90/"},{"name":"书法","slug":"书法","permalink":"http://yoursite.com/tags/%E4%B9%A6%E6%B3%95/"},{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"健身","slug":"健身","permalink":"http://yoursite.com/tags/%E5%81%A5%E8%BA%AB/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"}]}